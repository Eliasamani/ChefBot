#!/usr/bin/env node
import Wn from "url";
import Yn from "fs";
import Rn from "path";
import kt, { argv as Zn, env as Ie, stdout as Qn, exit as lr, cwd as Jn } from "node:process";
import { dirname as Vt, resolve as ze, basename as We, join as Xt } from "node:path";
import { readFileSync as cr, truncateSync as es, writeFileSync as ts, lstatSync as ur, accessSync as rs } from "node:fs";
import ns from "node:os";
import fr from "node:tty";
import { execFileSync as ss } from "node:child_process";
function is({ onlyFirst: e = !1 } = {}) {
  const r = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(r, e ? void 0 : "g");
}
function st(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function os(e, t) {
  var r = e;
  t.slice(0, -1).forEach(function(i) {
    r = r[i] || {};
  });
  var n = t[t.length - 1];
  return n in r;
}
function pr(e) {
  return typeof e == "number" || /^0x[0-9a-f]+$/i.test(e) ? !0 : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(e);
}
function hr(e, t) {
  return t === "constructor" && typeof e[t] == "function" || t === "__proto__";
}
var An = function(e, t) {
  t || (t = {});
  var r = {
    bools: {},
    strings: {},
    unknownFn: null
  };
  typeof t.unknown == "function" && (r.unknownFn = t.unknown), typeof t.boolean == "boolean" && t.boolean ? r.allBools = !0 : [].concat(t.boolean).filter(Boolean).forEach(function(T) {
    r.bools[T] = !0;
  });
  var n = {};
  function i(T) {
    return n[T].some(function(D) {
      return r.bools[D];
    });
  }
  Object.keys(t.alias || {}).forEach(function(T) {
    n[T] = [].concat(t.alias[T]), n[T].forEach(function(D) {
      n[D] = [T].concat(n[T].filter(function(U) {
        return D !== U;
      }));
    });
  }), [].concat(t.string).filter(Boolean).forEach(function(T) {
    r.strings[T] = !0, n[T] && [].concat(n[T]).forEach(function(D) {
      r.strings[D] = !0;
    });
  });
  var s = t.default || {}, o = { _: [] };
  function a(T, D) {
    return r.allBools && /^--[^=]+$/.test(D) || r.strings[T] || r.bools[T] || n[T];
  }
  function l(T, D, U) {
    for (var H = T, P = 0; P < D.length - 1; P++) {
      var L = D[P];
      if (hr(H, L))
        return;
      H[L] === void 0 && (H[L] = {}), (H[L] === Object.prototype || H[L] === Number.prototype || H[L] === String.prototype) && (H[L] = {}), H[L] === Array.prototype && (H[L] = []), H = H[L];
    }
    var E = D[D.length - 1];
    hr(H, E) || ((H === Object.prototype || H === Number.prototype || H === String.prototype) && (H = {}), H === Array.prototype && (H = []), H[E] === void 0 || r.bools[E] || typeof H[E] == "boolean" ? H[E] = U : Array.isArray(H[E]) ? H[E].push(U) : H[E] = [H[E], U]);
  }
  function u(T, D, U) {
    if (!(U && r.unknownFn && !a(T, U) && r.unknownFn(U) === !1)) {
      var H = !r.strings[T] && pr(D) ? Number(D) : D;
      l(o, T.split("."), H), (n[T] || []).forEach(function(P) {
        l(o, P.split("."), H);
      });
    }
  }
  Object.keys(r.bools).forEach(function(T) {
    u(T, s[T] === void 0 ? !1 : s[T]);
  });
  var c = [];
  e.indexOf("--") !== -1 && (c = e.slice(e.indexOf("--") + 1), e = e.slice(0, e.indexOf("--")));
  for (var g = 0; g < e.length; g++) {
    var d = e[g], h, S;
    if (/^--.+=/.test(d)) {
      var N = d.match(/^--([^=]+)=([\s\S]*)$/);
      h = N[1];
      var R = N[2];
      r.bools[h] && (R = R !== "false"), u(h, R, d);
    } else if (/^--no-.+/.test(d))
      h = d.match(/^--no-(.+)/)[1], u(h, !1, d);
    else if (/^--.+/.test(d))
      h = d.match(/^--(.+)/)[1], S = e[g + 1], S !== void 0 && !/^(-|--)[^-]/.test(S) && !r.bools[h] && !r.allBools && (!n[h] || !i(h)) ? (u(h, S, d), g += 1) : /^(true|false)$/.test(S) ? (u(h, S === "true", d), g += 1) : u(h, r.strings[h] ? "" : !0, d);
    else if (/^-[^-]+/.test(d)) {
      for (var I = d.slice(1, -1).split(""), C = !1, y = 0; y < I.length; y++) {
        if (S = d.slice(y + 2), S === "-") {
          u(I[y], S, d);
          continue;
        }
        if (/[A-Za-z]/.test(I[y]) && S[0] === "=") {
          u(I[y], S.slice(1), d), C = !0;
          break;
        }
        if (/[A-Za-z]/.test(I[y]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(S)) {
          u(I[y], S, d), C = !0;
          break;
        }
        if (I[y + 1] && I[y + 1].match(/\W/)) {
          u(I[y], d.slice(y + 2), d), C = !0;
          break;
        } else
          u(I[y], r.strings[I[y]] ? "" : !0, d);
      }
      h = d.slice(-1)[0], !C && h !== "-" && (e[g + 1] && !/^(-|--)[^-]/.test(e[g + 1]) && !r.bools[h] && (!n[h] || !i(h)) ? (u(h, e[g + 1], d), g += 1) : e[g + 1] && /^(true|false)$/.test(e[g + 1]) ? (u(h, e[g + 1] === "true", d), g += 1) : u(h, r.strings[h] ? "" : !0, d));
    } else if ((!r.unknownFn || r.unknownFn(d) !== !1) && o._.push(r.strings._ || !pr(d) ? d : Number(d)), t.stopEarly) {
      o._.push.apply(o._, e.slice(g + 1));
      break;
    }
  }
  return Object.keys(s).forEach(function(T) {
    os(o, T.split(".")) || (l(o, T.split("."), s[T]), (n[T] || []).forEach(function(D) {
      l(o, D.split("."), s[T]);
    }));
  }), t["--"] ? o["--"] = c.slice() : c.forEach(function(T) {
    o._.push(T);
  }), o;
};
const as = /* @__PURE__ */ st(An);
function ls(e) {
  return Buffer.from(e, "base64").toString("utf8");
}
function cs(e) {
  return Buffer.from(e, "utf8").toString("base64");
}
var us = {
  decodeBase64: ls,
  encodeBase64: cs
}, ve = {}, me = {}, dr;
function fs() {
  if (dr) return me;
  dr = 1, me.parse = me.decode = n, me.stringify = me.encode = t, me.safe = s, me.unsafe = o;
  var e = typeof process < "u" && process.platform === "win32" ? `\r
` : `
`;
  function t(a, l) {
    var u = [], c = "";
    typeof l == "string" ? l = {
      section: l,
      whitespace: !1
    } : (l = l || {}, l.whitespace = l.whitespace === !0);
    var g = l.whitespace ? " = " : "=";
    return Object.keys(a).forEach(function(d, h, S) {
      var N = a[d];
      N && Array.isArray(N) ? N.forEach(function(R) {
        c += s(d + "[]") + g + s(R) + `
`;
      }) : N && typeof N == "object" ? u.push(d) : c += s(d) + g + s(N) + e;
    }), l.section && c.length && (c = "[" + s(l.section) + "]" + e + c), u.forEach(function(d, h, S) {
      var N = r(d).join("\\."), R = (l.section ? l.section + "." : "") + N, I = t(a[d], {
        section: R,
        whitespace: l.whitespace
      });
      c.length && I.length && (c += e), c += I;
    }), c;
  }
  function r(a) {
    return a.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(l) {
      return l.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
    });
  }
  function n(a) {
    var l = {}, u = l, c = null, g = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, d = a.split(/[\r\n]+/g);
    return d.forEach(function(h, S, N) {
      if (!(!h || h.match(/^\s*[;#]/))) {
        var R = h.match(g);
        if (R) {
          if (R[1] !== void 0) {
            if (c = o(R[1]), c === "__proto__") {
              u = {};
              return;
            }
            u = l[c] = l[c] || {};
            return;
          }
          var I = o(R[2]);
          if (I !== "__proto__") {
            var C = R[3] ? o(R[4]) : !0;
            switch (C) {
              case "true":
              case "false":
              case "null":
                C = JSON.parse(C);
            }
            if (I.length > 2 && I.slice(-2) === "[]") {
              if (I = I.substring(0, I.length - 2), I === "__proto__")
                return;
              u[I] ? Array.isArray(u[I]) || (u[I] = [u[I]]) : u[I] = [];
            }
            Array.isArray(u[I]) ? u[I].push(C) : u[I] = C;
          }
        }
      }
    }), Object.keys(l).filter(function(h, S, N) {
      if (!l[h] || typeof l[h] != "object" || Array.isArray(l[h]))
        return !1;
      var R = r(h), I = l, C = R.pop(), y = C.replace(/\\\./g, ".");
      return R.forEach(function(T, D, U) {
        T !== "__proto__" && ((!I[T] || typeof I[T] != "object") && (I[T] = {}), I = I[T]);
      }), I === l && y === C ? !1 : (I[y] = l[h], !0);
    }).forEach(function(h, S, N) {
      delete l[h];
    }), l;
  }
  function i(a) {
    return a.charAt(0) === '"' && a.slice(-1) === '"' || a.charAt(0) === "'" && a.slice(-1) === "'";
  }
  function s(a) {
    return typeof a != "string" || a.match(/[=\r\n]/) || a.match(/^\[/) || a.length > 1 && i(a) || a !== a.trim() ? JSON.stringify(a) : a.replace(/;/g, "\\;").replace(/#/g, "\\#");
  }
  function o(a, l) {
    if (a = (a || "").trim(), i(a)) {
      a.charAt(0) === "'" && (a = a.substr(1, a.length - 2));
      try {
        a = JSON.parse(a);
      } catch {
      }
    } else {
      for (var u = !1, c = "", g = 0, d = a.length; g < d; g++) {
        var h = a.charAt(g);
        if (u)
          "\\;#".indexOf(h) !== -1 ? c += h : c += "\\" + h, u = !1;
        else {
          if (";#".indexOf(h) !== -1)
            break;
          h === "\\" ? u = !0 : c += h;
        }
      }
      return u && (c += "\\"), c.trim();
    }
    return a;
  }
  return me;
}
var Et, gr;
function ps() {
  if (gr) return Et;
  gr = 1;
  var e = 1, t = 2;
  function r() {
    return "";
  }
  function n(i, s, o) {
    return i.slice(s, o).replace(/\S/g, " ");
  }
  return Et = function(i, s) {
    s = s || {};
    for (var o, a, l = !1, u = !1, c = 0, g = "", d = s.whitespace === !1 ? r : n, h = 0; h < i.length; h++) {
      if (o = i[h], a = i[h + 1], !u && o === '"') {
        var S = i[h - 1] === "\\" && i[h - 2] !== "\\";
        S || (l = !l);
      }
      if (!l) {
        if (!u && o + a === "//")
          g += i.slice(c, h), c = h, u = e, h++;
        else if (u === e && o + a === `\r
`) {
          h++, u = !1, g += d(i, c, h), c = h;
          continue;
        } else if (u === e && o === `
`)
          u = !1, g += d(i, c, h), c = h;
        else if (!u && o + a === "/*") {
          g += i.slice(c, h), c = h, u = t, h++;
          continue;
        } else if (u === t && o + a === "*/") {
          h++, u = !1, g += d(i, c, h + 1), c = h + 1;
          continue;
        }
      }
    }
    return g + (u ? d(i.substr(c)) : i.substr(c));
  }, Et;
}
var Er;
function hs() {
  if (Er) return ve;
  Er = 1;
  var e = Yn, t = fs(), r = Rn, n = ps(), i = ve.parse = function(o) {
    return /^\s*{/.test(o) ? JSON.parse(n(o)) : t.parse(o);
  }, s = ve.file = function() {
    var o = [].slice.call(arguments).filter(function(u) {
      return u != null;
    });
    for (var a in o)
      if (typeof o[a] != "string")
        return;
    var l = r.join.apply(null, o);
    try {
      return e.readFileSync(l, "utf-8");
    } catch {
      return;
    }
  };
  return ve.json = function() {
    var o = s.apply(null, arguments);
    return o ? i(o) : null;
  }, ve.env = function(o, a) {
    a = a || process.env;
    var l = {}, u = o.length;
    for (var c in a)
      if (c.toLowerCase().indexOf(o.toLowerCase()) === 0) {
        for (var g = c.substring(u).split("__"), d; (d = g.indexOf("")) > -1; )
          g.splice(d, 1);
        var h = l;
        g.forEach(function(N, R) {
          !N || typeof h != "object" || (R === g.length - 1 && (h[N] = a[c]), h[N] === void 0 && (h[N] = {}), h = h[N]);
        });
      }
    return l;
  }, ve.find = function() {
    var o = r.join.apply(null, [].slice.call(arguments));
    function a(l, u) {
      var c = r.join(l, u);
      try {
        return e.statSync(c), c;
      } catch {
        if (r.dirname(l) !== l)
          return a(r.dirname(l), u);
      }
    }
    return a(process.cwd(), o);
  }, ve;
}
var mt = { exports: {} };
var mr;
function ds() {
  if (mr) return mt.exports;
  mr = 1;
  function e(s) {
    return s instanceof Buffer || s instanceof Date || s instanceof RegExp;
  }
  function t(s) {
    if (s instanceof Buffer) {
      var o = Buffer.alloc ? Buffer.alloc(s.length) : new Buffer(s.length);
      return s.copy(o), o;
    } else {
      if (s instanceof Date)
        return new Date(s.getTime());
      if (s instanceof RegExp)
        return new RegExp(s);
      throw new Error("Unexpected situation");
    }
  }
  function r(s) {
    var o = [];
    return s.forEach(function(a, l) {
      typeof a == "object" && a !== null ? Array.isArray(a) ? o[l] = r(a) : e(a) ? o[l] = t(a) : o[l] = i({}, a) : o[l] = a;
    }), o;
  }
  function n(s, o) {
    return o === "__proto__" ? void 0 : s[o];
  }
  var i = mt.exports = function() {
    if (arguments.length < 1 || typeof arguments[0] != "object")
      return !1;
    if (arguments.length < 2)
      return arguments[0];
    var s = arguments[0], o = Array.prototype.slice.call(arguments, 1), a, l;
    return o.forEach(function(u) {
      typeof u != "object" || u === null || Array.isArray(u) || Object.keys(u).forEach(function(c) {
        if (l = n(s, c), a = n(u, c), a !== s)
          if (typeof a != "object" || a === null) {
            s[c] = a;
            return;
          } else if (Array.isArray(a)) {
            s[c] = r(a);
            return;
          } else if (e(a)) {
            s[c] = t(a);
            return;
          } else if (typeof l != "object" || l === null || Array.isArray(l)) {
            s[c] = i({}, a);
            return;
          } else {
            s[c] = i(l, a);
            return;
          }
      });
    }), s;
  };
  return mt.exports;
}
var $t, $r;
function wn() {
  if ($r) return $t;
  $r = 1;
  var e = hs(), t = Rn.join, r = ds(), n = "/etc", i = process.platform === "win32", s = i ? process.env.USERPROFILE : process.env.HOME;
  return $t = function(o, a, l, u) {
    if (typeof o != "string")
      throw new Error("rc(name): name *must* be string");
    l || (l = An(process.argv.slice(2))), a = (typeof a == "string" ? e.json(a) : a) || {}, u = u || e.parse;
    var c = e.env(o + "_"), g = [a], d = [];
    function h(S) {
      if (!(d.indexOf(S) >= 0)) {
        var N = e.file(S);
        N && (g.push(u(N)), d.push(S));
      }
    }
    return i || [
      t(n, o, "config"),
      t(n, o + "rc")
    ].forEach(h), s && [
      t(s, ".config", o, "config"),
      t(s, ".config", o),
      t(s, "." + o, "config"),
      t(s, "." + o + "rc")
    ].forEach(h), h(e.find("." + o + "rc")), c.config && h(c.config), l.config && h(l.config), r.apply(null, g.concat([
      c,
      l,
      d.length ? { configs: d, config: d[d.length - 1] } : void 0
    ]));
  }, $t;
}
var vt = Wn, Sn = us, gs = Sn.decodeBase64, Es = Sn.encodeBase64, vr = ":_authToken", yr = ":_auth", Rr = ":username", Ar = ":_password", ms = function() {
  var e, t;
  return arguments.length >= 2 ? (e = arguments[0], t = arguments[1]) : typeof arguments[0] == "string" ? e = arguments[0] : t = arguments[0], t = t || {}, t.npmrc = t.npmrc || wn()("npm", { registry: "https://registry.npmjs.org/" }, {
    config: process.env.npm_config_userconfig || process.env.NPM_CONFIG_USERCONFIG
  }), e = e || t.npmrc.registry, _n(e, t) || $s(t.npmrc);
};
function _n(e, t) {
  for (var r = vt.parse(e, !1, !0), n; n !== "/" && r.pathname !== n; ) {
    n = r.pathname || "/";
    var i = "//" + r.host + n.replace(/\/$/, ""), s = ys(i, t.npmrc);
    if (s)
      return s;
    if (!t.recursive)
      return /\/$/.test(e) ? void 0 : _n(vt.resolve(e, "."), t);
    r.pathname = vt.resolve(vs(n), "..") || "/";
  }
}
function $s(e) {
  if (e._auth) {
    var t = it(e._auth);
    return { token: t, type: "Basic" };
  }
}
function vs(e) {
  return e[e.length - 1] === "/" ? e : e + "/";
}
function ys(e, t) {
  var r = Rs(t[e + vr] || t[e + "/" + vr]);
  if (r)
    return r;
  var n = t[e + Rr] || t[e + "/" + Rr], i = t[e + Ar] || t[e + "/" + Ar], s = As(n, i);
  if (s)
    return s;
  var o = ws(t[e + yr] || t[e + "/" + yr]);
  if (o)
    return o;
}
function it(e) {
  return e.replace(/^\$\{?([^}]*)\}?$/, function(t, r) {
    return process.env[r];
  });
}
function Rs(e) {
  if (e) {
    var t = it(e);
    return { token: t, type: "Bearer" };
  }
}
function As(e, t) {
  if (!(!e || !t)) {
    var r = gs(it(t)), n = Es(e + ":" + r);
    return {
      token: n,
      type: "Basic",
      password: r,
      username: e
    };
  }
}
function ws(e) {
  if (e) {
    var t = it(e);
    return { token: t, type: "Basic" };
  }
}
const yt = /* @__PURE__ */ st(ms);
var Ss = wn();
const _s = /* @__PURE__ */ st(Ss);
var jt = { exports: {} };
const bs = "2.0.0", Os = 256, Ts = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, Is = 16;
var ot = {
  SEMVER_SPEC_VERSION: bs,
  MAX_LENGTH: Os,
  MAX_SAFE_INTEGER: Ts,
  MAX_SAFE_COMPONENT_LENGTH: Is
};
const xs = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var at = xs;
(function(e, t) {
  const { MAX_SAFE_COMPONENT_LENGTH: r } = ot, n = at;
  t = e.exports = {};
  const i = t.re = [], s = t.src = [], o = t.t = {};
  let a = 0;
  const l = (u, c, g) => {
    const d = a++;
    n(u, d, c), o[u] = d, s[d] = c, i[d] = new RegExp(c, g ? "g" : void 0);
  };
  l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${s[o.NUMERICIDENTIFIER]})\\.(${s[o.NUMERICIDENTIFIER]})\\.(${s[o.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${s[o.NUMERICIDENTIFIERLOOSE]})\\.(${s[o.NUMERICIDENTIFIERLOOSE]})\\.(${s[o.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${s[o.NUMERICIDENTIFIER]}|${s[o.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${s[o.NUMERICIDENTIFIERLOOSE]}|${s[o.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${s[o.PRERELEASEIDENTIFIER]}(?:\\.${s[o.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${s[o.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s[o.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${s[o.BUILDIDENTIFIER]}(?:\\.${s[o.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${s[o.MAINVERSION]}${s[o.PRERELEASE]}?${s[o.BUILD]}?`), l("FULL", `^${s[o.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${s[o.MAINVERSIONLOOSE]}${s[o.PRERELEASELOOSE]}?${s[o.BUILD]}?`), l("LOOSE", `^${s[o.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${s[o.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${s[o.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${s[o.XRANGEIDENTIFIER]})(?:\\.(${s[o.XRANGEIDENTIFIER]})(?:\\.(${s[o.XRANGEIDENTIFIER]})(?:${s[o.PRERELEASE]})?${s[o.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${s[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[o.XRANGEIDENTIFIERLOOSE]})(?:${s[o.PRERELEASELOOSE]})?${s[o.BUILD]}?)?)?`), l("XRANGE", `^${s[o.GTLT]}\\s*${s[o.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${s[o.GTLT]}\\s*${s[o.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?(?:$|[^\\d])`), l("COERCERTL", s[o.COERCE], !0), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${s[o.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", l("TILDE", `^${s[o.LONETILDE]}${s[o.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${s[o.LONETILDE]}${s[o.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${s[o.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", l("CARET", `^${s[o.LONECARET]}${s[o.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${s[o.LONECARET]}${s[o.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${s[o.GTLT]}\\s*(${s[o.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${s[o.GTLT]}\\s*(${s[o.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${s[o.GTLT]}\\s*(${s[o.LOOSEPLAIN]}|${s[o.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${s[o.XRANGEPLAIN]})\\s+-\\s+(${s[o.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${s[o.XRANGEPLAINLOOSE]})\\s+-\\s+(${s[o.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(jt, jt.exports);
var Ce = jt.exports;
const Ns = ["includePrerelease", "loose", "rtl"], Cs = (e) => e ? typeof e != "object" ? { loose: !0 } : Ns.filter((t) => e[t]).reduce((t, r) => (t[r] = !0, t), {}) : {};
var lt = Cs;
const wr = /^[0-9]+$/, bn = (e, t) => {
  const r = wr.test(e), n = wr.test(t);
  return r && n && (e = +e, t = +t), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1;
}, Ls = (e, t) => bn(t, e);
var On = {
  compareIdentifiers: bn,
  rcompareIdentifiers: Ls
};
const Ve = at, { MAX_LENGTH: Sr, MAX_SAFE_INTEGER: Xe } = ot, { re: _r, t: br } = Ce, Ps = lt, { compareIdentifiers: _e } = On;
let Ds = class le {
  constructor(t, r) {
    if (r = Ps(r), t instanceof le) {
      if (t.loose === !!r.loose && t.includePrerelease === !!r.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid Version: ${t}`);
    if (t.length > Sr)
      throw new TypeError(
        `version is longer than ${Sr} characters`
      );
    Ve("SemVer", t, r), this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease;
    const n = t.trim().match(r.loose ? _r[br.LOOSE] : _r[br.FULL]);
    if (!n)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > Xe || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Xe || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Xe || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n[4] ? this.prerelease = n[4].split(".").map((i) => {
      if (/^[0-9]+$/.test(i)) {
        const s = +i;
        if (s >= 0 && s < Xe)
          return s;
      }
      return i;
    }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (Ve("SemVer.compare", this.version, this.options, t), !(t instanceof le)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new le(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof le || (t = new le(t, this.options)), _e(this.major, t.major) || _e(this.minor, t.minor) || _e(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof le || (t = new le(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let r = 0;
    do {
      const n = this.prerelease[r], i = t.prerelease[r];
      if (Ve("prerelease compare", r, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return _e(n, i);
    } while (++r);
  }
  compareBuild(t) {
    t instanceof le || (t = new le(t, this.options));
    let r = 0;
    do {
      const n = this.build[r], i = t.build[r];
      if (Ve("prerelease compare", r, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return _e(n, i);
    } while (++r);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, r) {
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", r), this.inc("pre", r);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", r), this.inc("pre", r);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          let n = this.prerelease.length;
          for (; --n >= 0; )
            typeof this.prerelease[n] == "number" && (this.prerelease[n]++, n = -2);
          n === -1 && this.prerelease.push(0);
        }
        r && (_e(this.prerelease[0], r) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [r, 0]) : this.prerelease = [r, 0]);
        break;
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.format(), this.raw = this.version, this;
  }
};
var re = Ds;
const { MAX_LENGTH: Hs } = ot, { re: Or, t: Tr } = Ce, Ir = re, js = lt, Gs = (e, t) => {
  if (t = js(t), e instanceof Ir)
    return e;
  if (typeof e != "string" || e.length > Hs || !(t.loose ? Or[Tr.LOOSE] : Or[Tr.FULL]).test(e))
    return null;
  try {
    return new Ir(e, t);
  } catch {
    return null;
  }
};
var Le = Gs;
const Bs = Le, Fs = (e, t) => {
  const r = Bs(e, t);
  return r ? r.version : null;
};
var Ms = Fs;
const Us = Le, ks = (e, t) => {
  const r = Us(e.trim().replace(/^[=v]+/, ""), t);
  return r ? r.version : null;
};
var Vs = ks;
const xr = re, Xs = (e, t, r, n) => {
  typeof r == "string" && (n = r, r = void 0);
  try {
    return new xr(
      e instanceof xr ? e.version : e,
      r
    ).inc(t, n).version;
  } catch {
    return null;
  }
};
var qs = Xs;
const Nr = re, Ks = (e, t, r) => new Nr(e, r).compare(new Nr(t, r));
var oe = Ks;
const zs = oe, Ws = (e, t, r) => zs(e, t, r) === 0;
var qt = Ws;
const Cr = Le, Ys = qt, Zs = (e, t) => {
  if (Ys(e, t))
    return null;
  {
    const r = Cr(e), n = Cr(t), i = r.prerelease.length || n.prerelease.length, s = i ? "pre" : "", o = i ? "prerelease" : "";
    for (const a in r)
      if ((a === "major" || a === "minor" || a === "patch") && r[a] !== n[a])
        return s + a;
    return o;
  }
};
var Qs = Zs;
const Js = re, ei = (e, t) => new Js(e, t).major;
var ti = ei;
const ri = re, ni = (e, t) => new ri(e, t).minor;
var si = ni;
const ii = re, oi = (e, t) => new ii(e, t).patch;
var ai = oi;
const li = Le, ci = (e, t) => {
  const r = li(e, t);
  return r && r.prerelease.length ? r.prerelease : null;
};
var ui = ci;
const fi = oe, pi = (e, t, r) => fi(t, e, r);
var hi = pi;
const di = oe, gi = (e, t) => di(e, t, !0);
var Ei = gi;
const Lr = re, mi = (e, t, r) => {
  const n = new Lr(e, r), i = new Lr(t, r);
  return n.compare(i) || n.compareBuild(i);
};
var Kt = mi;
const $i = Kt, vi = (e, t) => e.sort((r, n) => $i(r, n, t));
var yi = vi;
const Ri = Kt, Ai = (e, t) => e.sort((r, n) => Ri(n, r, t));
var wi = Ai;
const Si = oe, _i = (e, t, r) => Si(e, t, r) > 0;
var ct = _i;
const bi = oe, Oi = (e, t, r) => bi(e, t, r) < 0;
var zt = Oi;
const Ti = oe, Ii = (e, t, r) => Ti(e, t, r) !== 0;
var Tn = Ii;
const xi = oe, Ni = (e, t, r) => xi(e, t, r) >= 0;
var Wt = Ni;
const Ci = oe, Li = (e, t, r) => Ci(e, t, r) <= 0;
var Yt = Li;
const Pi = qt, Di = Tn, Hi = ct, ji = Wt, Gi = zt, Bi = Yt, Fi = (e, t, r, n) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r;
    case "":
    case "=":
    case "==":
      return Pi(e, r, n);
    case "!=":
      return Di(e, r, n);
    case ">":
      return Hi(e, r, n);
    case ">=":
      return ji(e, r, n);
    case "<":
      return Gi(e, r, n);
    case "<=":
      return Bi(e, r, n);
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
var In = Fi;
const Mi = re, Ui = Le, { re: qe, t: Ke } = Ce, ki = (e, t) => {
  if (e instanceof Mi)
    return e;
  if (typeof e == "number" && (e = String(e)), typeof e != "string")
    return null;
  t = t || {};
  let r = null;
  if (!t.rtl)
    r = e.match(qe[Ke.COERCE]);
  else {
    let n;
    for (; (n = qe[Ke.COERCERTL].exec(e)) && (!r || r.index + r[0].length !== e.length); )
      (!r || n.index + n[0].length !== r.index + r[0].length) && (r = n), qe[Ke.COERCERTL].lastIndex = n.index + n[1].length + n[2].length;
    qe[Ke.COERCERTL].lastIndex = -1;
  }
  return r === null ? null : Ui(`${r[2]}.${r[3] || "0"}.${r[4] || "0"}`, t);
};
var Vi = ki, Rt, Pr;
function Xi() {
  return Pr || (Pr = 1, Rt = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let t = this.head; t; t = t.next)
        yield t.value;
    };
  }), Rt;
}
var qi = k;
k.Node = Se;
k.create = k;
function k(e) {
  var t = this;
  if (t instanceof k || (t = new k()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
    e.forEach(function(i) {
      t.push(i);
    });
  else if (arguments.length > 0)
    for (var r = 0, n = arguments.length; r < n; r++)
      t.push(arguments[r]);
  return t;
}
k.prototype.removeNode = function(e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next, r = e.prev;
  return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
};
k.prototype.unshiftNode = function(e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
  }
};
k.prototype.pushNode = function(e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
  }
};
k.prototype.push = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    zi(this, arguments[e]);
  return this.length;
};
k.prototype.unshift = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    Wi(this, arguments[e]);
  return this.length;
};
k.prototype.pop = function() {
  if (this.tail) {
    var e = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
  }
};
k.prototype.shift = function() {
  if (this.head) {
    var e = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
  }
};
k.prototype.forEach = function(e, t) {
  t = t || this;
  for (var r = this.head, n = 0; r !== null; n++)
    e.call(t, r.value, n, this), r = r.next;
};
k.prototype.forEachReverse = function(e, t) {
  t = t || this;
  for (var r = this.tail, n = this.length - 1; r !== null; n--)
    e.call(t, r.value, n, this), r = r.prev;
};
k.prototype.get = function(e) {
  for (var t = 0, r = this.head; r !== null && t < e; t++)
    r = r.next;
  if (t === e && r !== null)
    return r.value;
};
k.prototype.getReverse = function(e) {
  for (var t = 0, r = this.tail; r !== null && t < e; t++)
    r = r.prev;
  if (t === e && r !== null)
    return r.value;
};
k.prototype.map = function(e, t) {
  t = t || this;
  for (var r = new k(), n = this.head; n !== null; )
    r.push(e.call(t, n.value, this)), n = n.next;
  return r;
};
k.prototype.mapReverse = function(e, t) {
  t = t || this;
  for (var r = new k(), n = this.tail; n !== null; )
    r.push(e.call(t, n.value, this)), n = n.prev;
  return r;
};
k.prototype.reduce = function(e, t) {
  var r, n = this.head;
  if (arguments.length > 1)
    r = t;
  else if (this.head)
    n = this.head.next, r = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var i = 0; n !== null; i++)
    r = e(r, n.value, i), n = n.next;
  return r;
};
k.prototype.reduceReverse = function(e, t) {
  var r, n = this.tail;
  if (arguments.length > 1)
    r = t;
  else if (this.tail)
    n = this.tail.prev, r = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var i = this.length - 1; n !== null; i--)
    r = e(r, n.value, i), n = n.prev;
  return r;
};
k.prototype.toArray = function() {
  for (var e = new Array(this.length), t = 0, r = this.head; r !== null; t++)
    e[t] = r.value, r = r.next;
  return e;
};
k.prototype.toArrayReverse = function() {
  for (var e = new Array(this.length), t = 0, r = this.tail; r !== null; t++)
    e[t] = r.value, r = r.prev;
  return e;
};
k.prototype.slice = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var r = new k();
  if (t < e || t < 0)
    return r;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var n = 0, i = this.head; i !== null && n < e; n++)
    i = i.next;
  for (; i !== null && n < t; n++, i = i.next)
    r.push(i.value);
  return r;
};
k.prototype.sliceReverse = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var r = new k();
  if (t < e || t < 0)
    return r;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var n = this.length, i = this.tail; i !== null && n > t; n--)
    i = i.prev;
  for (; i !== null && n > e; n--, i = i.prev)
    r.push(i.value);
  return r;
};
k.prototype.splice = function(e, t, ...r) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var n = 0, i = this.head; i !== null && n < e; n++)
    i = i.next;
  for (var s = [], n = 0; i && n < t; n++)
    s.push(i.value), i = this.removeNode(i);
  i === null && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev);
  for (var n = 0; n < r.length; n++)
    i = Ki(this, i, r[n]);
  return s;
};
k.prototype.reverse = function() {
  for (var e = this.head, t = this.tail, r = e; r !== null; r = r.prev) {
    var n = r.prev;
    r.prev = r.next, r.next = n;
  }
  return this.head = t, this.tail = e, this;
};
function Ki(e, t, r) {
  var n = t === e.head ? new Se(r, null, t, e) : new Se(r, t, t.next, e);
  return n.next === null && (e.tail = n), n.prev === null && (e.head = n), e.length++, n;
}
function zi(e, t) {
  e.tail = new Se(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
}
function Wi(e, t) {
  e.head = new Se(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
}
function Se(e, t, r, n) {
  if (!(this instanceof Se))
    return new Se(e, t, r, n);
  this.list = n, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
}
try {
  Xi()(k);
} catch {
}
const Yi = qi, Re = Symbol("max"), he = Symbol("length"), be = Symbol("lengthCalculator"), je = Symbol("allowStale"), Ae = Symbol("maxAge"), pe = Symbol("dispose"), Dr = Symbol("noDisposeOnSet"), J = Symbol("lruList"), ie = Symbol("cache"), xn = Symbol("updateAgeOnGet"), At = () => 1;
class Zi {
  constructor(t) {
    if (typeof t == "number" && (t = { max: t }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[Re] = t.max || 1 / 0;
    const r = t.length || At;
    if (this[be] = typeof r != "function" ? At : r, this[je] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[Ae] = t.maxAge || 0, this[pe] = t.dispose, this[Dr] = t.noDisposeOnSet || !1, this[xn] = t.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    this[Re] = t || 1 / 0, Pe(this);
  }
  get max() {
    return this[Re];
  }
  set allowStale(t) {
    this[je] = !!t;
  }
  get allowStale() {
    return this[je];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[Ae] = t, Pe(this);
  }
  get maxAge() {
    return this[Ae];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(t) {
    typeof t != "function" && (t = At), t !== this[be] && (this[be] = t, this[he] = 0, this[J].forEach((r) => {
      r.length = this[be](r.value, r.key), this[he] += r.length;
    })), Pe(this);
  }
  get lengthCalculator() {
    return this[be];
  }
  get length() {
    return this[he];
  }
  get itemCount() {
    return this[J].length;
  }
  rforEach(t, r) {
    r = r || this;
    for (let n = this[J].tail; n !== null; ) {
      const i = n.prev;
      Hr(this, t, n, r), n = i;
    }
  }
  forEach(t, r) {
    r = r || this;
    for (let n = this[J].head; n !== null; ) {
      const i = n.next;
      Hr(this, t, n, r), n = i;
    }
  }
  keys() {
    return this[J].toArray().map((t) => t.key);
  }
  values() {
    return this[J].toArray().map((t) => t.value);
  }
  reset() {
    this[pe] && this[J] && this[J].length && this[J].forEach((t) => this[pe](t.key, t.value)), this[ie] = /* @__PURE__ */ new Map(), this[J] = new Yi(), this[he] = 0;
  }
  dump() {
    return this[J].map((t) => Qe(this, t) ? !1 : {
      k: t.key,
      v: t.value,
      e: t.now + (t.maxAge || 0)
    }).toArray().filter((t) => t);
  }
  dumpLru() {
    return this[J];
  }
  set(t, r, n) {
    if (n = n || this[Ae], n && typeof n != "number")
      throw new TypeError("maxAge must be a number");
    const i = n ? Date.now() : 0, s = this[be](r, t);
    if (this[ie].has(t)) {
      if (s > this[Re])
        return Ne(this, this[ie].get(t)), !1;
      const l = this[ie].get(t).value;
      return this[pe] && (this[Dr] || this[pe](t, l.value)), l.now = i, l.maxAge = n, l.value = r, this[he] += s - l.length, l.length = s, this.get(t), Pe(this), !0;
    }
    const o = new Qi(t, r, s, i, n);
    return o.length > this[Re] ? (this[pe] && this[pe](t, r), !1) : (this[he] += o.length, this[J].unshift(o), this[ie].set(t, this[J].head), Pe(this), !0);
  }
  has(t) {
    if (!this[ie].has(t)) return !1;
    const r = this[ie].get(t).value;
    return !Qe(this, r);
  }
  get(t) {
    return wt(this, t, !0);
  }
  peek(t) {
    return wt(this, t, !1);
  }
  pop() {
    const t = this[J].tail;
    return t ? (Ne(this, t), t.value) : null;
  }
  del(t) {
    Ne(this, this[ie].get(t));
  }
  load(t) {
    this.reset();
    const r = Date.now();
    for (let n = t.length - 1; n >= 0; n--) {
      const i = t[n], s = i.e || 0;
      if (s === 0)
        this.set(i.k, i.v);
      else {
        const o = s - r;
        o > 0 && this.set(i.k, i.v, o);
      }
    }
  }
  prune() {
    this[ie].forEach((t, r) => wt(this, r, !1));
  }
}
const wt = (e, t, r) => {
  const n = e[ie].get(t);
  if (n) {
    const i = n.value;
    if (Qe(e, i)) {
      if (Ne(e, n), !e[je])
        return;
    } else
      r && (e[xn] && (n.value.now = Date.now()), e[J].unshiftNode(n));
    return i.value;
  }
}, Qe = (e, t) => {
  if (!t || !t.maxAge && !e[Ae])
    return !1;
  const r = Date.now() - t.now;
  return t.maxAge ? r > t.maxAge : e[Ae] && r > e[Ae];
}, Pe = (e) => {
  if (e[he] > e[Re])
    for (let t = e[J].tail; e[he] > e[Re] && t !== null; ) {
      const r = t.prev;
      Ne(e, t), t = r;
    }
}, Ne = (e, t) => {
  if (t) {
    const r = t.value;
    e[pe] && e[pe](r.key, r.value), e[he] -= r.length, e[ie].delete(r.key), e[J].removeNode(t);
  }
};
class Qi {
  constructor(t, r, n, i, s) {
    this.key = t, this.value = r, this.length = n, this.now = i, this.maxAge = s || 0;
  }
}
const Hr = (e, t, r, n) => {
  let i = r.value;
  Qe(e, i) && (Ne(e, r), e[je] || (i = void 0)), i && t.call(n, i.value, i.key, e);
};
var Ji = Zi, St, jr;
function ae() {
  if (jr) return St;
  jr = 1;
  class e {
    constructor($, b) {
      if (b = n(b), $ instanceof e)
        return $.loose === !!b.loose && $.includePrerelease === !!b.includePrerelease ? $ : new e($.raw, b);
      if ($ instanceof i)
        return this.raw = $.value, this.set = [[$]], this.format(), this;
      if (this.options = b, this.loose = !!b.loose, this.includePrerelease = !!b.includePrerelease, this.raw = $, this.set = $.split("||").map((f) => this.parseRange(f.trim())).filter((f) => f.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${$}`);
      if (this.set.length > 1) {
        const f = this.set[0];
        if (this.set = this.set.filter((p) => !d(p[0])), this.set.length === 0)
          this.set = [f];
        else if (this.set.length > 1) {
          for (const p of this.set)
            if (p.length === 1 && h(p[0])) {
              this.set = [p];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map(($) => $.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange($) {
      $ = $.trim();
      const f = `parseRange:${Object.keys(this.options).join(",")}:${$}`, p = r.get(f);
      if (p)
        return p;
      const m = this.options.loose, v = m ? a[l.HYPHENRANGELOOSE] : a[l.HYPHENRANGE];
      $ = $.replace(v, L(this.options.includePrerelease)), s("hyphen replace", $), $ = $.replace(a[l.COMPARATORTRIM], u), s("comparator trim", $), $ = $.replace(a[l.TILDETRIM], c), $ = $.replace(a[l.CARETTRIM], g), $ = $.split(/\s+/).join(" ");
      let A = $.split(" ").map((X) => N(X, this.options)).join(" ").split(/\s+/).map((X) => P(X, this.options));
      m && (A = A.filter((X) => (s("loose invalid filter", X, this.options), !!X.match(a[l.COMPARATORLOOSE])))), s("range list", A);
      const x = /* @__PURE__ */ new Map(), j = A.map((X) => new i(X, this.options));
      for (const X of j) {
        if (d(X))
          return [X];
        x.set(X.value, X);
      }
      x.size > 1 && x.has("") && x.delete("");
      const q = [...x.values()];
      return r.set(f, q), q;
    }
    intersects($, b) {
      if (!($ instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((f) => S(f, b) && $.set.some((p) => S(p, b) && f.every((m) => p.every((v) => m.intersects(v, b)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test($) {
      if (!$)
        return !1;
      if (typeof $ == "string")
        try {
          $ = new o($, this.options);
        } catch {
          return !1;
        }
      for (let b = 0; b < this.set.length; b++)
        if (E(this.set[b], $, this.options))
          return !0;
      return !1;
    }
  }
  St = e;
  const t = Ji, r = new t({ max: 1e3 }), n = lt, i = ut(), s = at, o = re, {
    re: a,
    t: l,
    comparatorTrimReplace: u,
    tildeTrimReplace: c,
    caretTrimReplace: g
  } = Ce, d = (w) => w.value === "<0.0.0-0", h = (w) => w.value === "", S = (w, $) => {
    let b = !0;
    const f = w.slice();
    let p = f.pop();
    for (; b && f.length; )
      b = f.every((m) => p.intersects(m, $)), p = f.pop();
    return b;
  }, N = (w, $) => (s("comp", w, $), w = y(w, $), s("caret", w), w = I(w, $), s("tildes", w), w = D(w, $), s("xrange", w), w = H(w, $), s("stars", w), w), R = (w) => !w || w.toLowerCase() === "x" || w === "*", I = (w, $) => w.trim().split(/\s+/).map((b) => C(b, $)).join(" "), C = (w, $) => {
    const b = $.loose ? a[l.TILDELOOSE] : a[l.TILDE];
    return w.replace(b, (f, p, m, v, A) => {
      s("tilde", w, f, p, m, v, A);
      let x;
      return R(p) ? x = "" : R(m) ? x = `>=${p}.0.0 <${+p + 1}.0.0-0` : R(v) ? x = `>=${p}.${m}.0 <${p}.${+m + 1}.0-0` : A ? (s("replaceTilde pr", A), x = `>=${p}.${m}.${v}-${A} <${p}.${+m + 1}.0-0`) : x = `>=${p}.${m}.${v} <${p}.${+m + 1}.0-0`, s("tilde return", x), x;
    });
  }, y = (w, $) => w.trim().split(/\s+/).map((b) => T(b, $)).join(" "), T = (w, $) => {
    s("caret", w, $);
    const b = $.loose ? a[l.CARETLOOSE] : a[l.CARET], f = $.includePrerelease ? "-0" : "";
    return w.replace(b, (p, m, v, A, x) => {
      s("caret", w, p, m, v, A, x);
      let j;
      return R(m) ? j = "" : R(v) ? j = `>=${m}.0.0${f} <${+m + 1}.0.0-0` : R(A) ? m === "0" ? j = `>=${m}.${v}.0${f} <${m}.${+v + 1}.0-0` : j = `>=${m}.${v}.0${f} <${+m + 1}.0.0-0` : x ? (s("replaceCaret pr", x), m === "0" ? v === "0" ? j = `>=${m}.${v}.${A}-${x} <${m}.${v}.${+A + 1}-0` : j = `>=${m}.${v}.${A}-${x} <${m}.${+v + 1}.0-0` : j = `>=${m}.${v}.${A}-${x} <${+m + 1}.0.0-0`) : (s("no pr"), m === "0" ? v === "0" ? j = `>=${m}.${v}.${A}${f} <${m}.${v}.${+A + 1}-0` : j = `>=${m}.${v}.${A}${f} <${m}.${+v + 1}.0-0` : j = `>=${m}.${v}.${A} <${+m + 1}.0.0-0`), s("caret return", j), j;
    });
  }, D = (w, $) => (s("replaceXRanges", w, $), w.split(/\s+/).map((b) => U(b, $)).join(" ")), U = (w, $) => {
    w = w.trim();
    const b = $.loose ? a[l.XRANGELOOSE] : a[l.XRANGE];
    return w.replace(b, (f, p, m, v, A, x) => {
      s("xRange", w, f, p, m, v, A, x);
      const j = R(m), q = j || R(v), X = q || R(A), Z = X;
      return p === "=" && Z && (p = ""), x = $.includePrerelease ? "-0" : "", j ? p === ">" || p === "<" ? f = "<0.0.0-0" : f = "*" : p && Z ? (q && (v = 0), A = 0, p === ">" ? (p = ">=", q ? (m = +m + 1, v = 0, A = 0) : (v = +v + 1, A = 0)) : p === "<=" && (p = "<", q ? m = +m + 1 : v = +v + 1), p === "<" && (x = "-0"), f = `${p + m}.${v}.${A}${x}`) : q ? f = `>=${m}.0.0${x} <${+m + 1}.0.0-0` : X && (f = `>=${m}.${v}.0${x} <${m}.${+v + 1}.0-0`), s("xRange return", f), f;
    });
  }, H = (w, $) => (s("replaceStars", w, $), w.trim().replace(a[l.STAR], "")), P = (w, $) => (s("replaceGTE0", w, $), w.trim().replace(a[$.includePrerelease ? l.GTE0PRE : l.GTE0], "")), L = (w) => ($, b, f, p, m, v, A, x, j, q, X, Z, Y) => (R(f) ? b = "" : R(p) ? b = `>=${f}.0.0${w ? "-0" : ""}` : R(m) ? b = `>=${f}.${p}.0${w ? "-0" : ""}` : v ? b = `>=${b}` : b = `>=${b}${w ? "-0" : ""}`, R(j) ? x = "" : R(q) ? x = `<${+j + 1}.0.0-0` : R(X) ? x = `<${j}.${+q + 1}.0-0` : Z ? x = `<=${j}.${q}.${X}-${Z}` : w ? x = `<${j}.${q}.${+X + 1}-0` : x = `<=${x}`, `${b} ${x}`.trim()), E = (w, $, b) => {
    for (let f = 0; f < w.length; f++)
      if (!w[f].test($))
        return !1;
    if ($.prerelease.length && !b.includePrerelease) {
      for (let f = 0; f < w.length; f++)
        if (s(w[f].semver), w[f].semver !== i.ANY && w[f].semver.prerelease.length > 0) {
          const p = w[f].semver;
          if (p.major === $.major && p.minor === $.minor && p.patch === $.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return St;
}
var _t, Gr;
function ut() {
  if (Gr) return _t;
  Gr = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(c, g) {
      if (g = r(g), c instanceof t) {
        if (c.loose === !!g.loose)
          return c;
        c = c.value;
      }
      o("comparator", c, g), this.options = g, this.loose = !!g.loose, this.parse(c), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(c) {
      const g = this.options.loose ? n[i.COMPARATORLOOSE] : n[i.COMPARATOR], d = c.match(g);
      if (!d)
        throw new TypeError(`Invalid comparator: ${c}`);
      this.operator = d[1] !== void 0 ? d[1] : "", this.operator === "=" && (this.operator = ""), d[2] ? this.semver = new a(d[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(c) {
      if (o("Comparator.test", c, this.options.loose), this.semver === e || c === e)
        return !0;
      if (typeof c == "string")
        try {
          c = new a(c, this.options);
        } catch {
          return !1;
        }
      return s(c, this.operator, this.semver, this.options);
    }
    intersects(c, g) {
      if (!(c instanceof t))
        throw new TypeError("a Comparator is required");
      if ((!g || typeof g != "object") && (g = {
        loose: !!g,
        includePrerelease: !1
      }), this.operator === "")
        return this.value === "" ? !0 : new l(c.value, g).test(this.value);
      if (c.operator === "")
        return c.value === "" ? !0 : new l(this.value, g).test(c.semver);
      const d = (this.operator === ">=" || this.operator === ">") && (c.operator === ">=" || c.operator === ">"), h = (this.operator === "<=" || this.operator === "<") && (c.operator === "<=" || c.operator === "<"), S = this.semver.version === c.semver.version, N = (this.operator === ">=" || this.operator === "<=") && (c.operator === ">=" || c.operator === "<="), R = s(this.semver, "<", c.semver, g) && (this.operator === ">=" || this.operator === ">") && (c.operator === "<=" || c.operator === "<"), I = s(this.semver, ">", c.semver, g) && (this.operator === "<=" || this.operator === "<") && (c.operator === ">=" || c.operator === ">");
      return d || h || S && N || R || I;
    }
  }
  _t = t;
  const r = lt, { re: n, t: i } = Ce, s = In, o = at, a = re, l = ae();
  return _t;
}
const eo = ae(), to = (e, t, r) => {
  try {
    t = new eo(t, r);
  } catch {
    return !1;
  }
  return t.test(e);
};
var ft = to;
const ro = ae(), no = (e, t) => new ro(e, t).set.map((r) => r.map((n) => n.value).join(" ").trim().split(" "));
var so = no;
const io = re, oo = ae(), ao = (e, t, r) => {
  let n = null, i = null, s = null;
  try {
    s = new oo(t, r);
  } catch {
    return null;
  }
  return e.forEach((o) => {
    s.test(o) && (!n || i.compare(o) === -1) && (n = o, i = new io(n, r));
  }), n;
};
var lo = ao;
const co = re, uo = ae(), fo = (e, t, r) => {
  let n = null, i = null, s = null;
  try {
    s = new uo(t, r);
  } catch {
    return null;
  }
  return e.forEach((o) => {
    s.test(o) && (!n || i.compare(o) === 1) && (n = o, i = new co(n, r));
  }), n;
};
var po = fo;
const bt = re, ho = ae(), Br = ct, go = (e, t) => {
  e = new ho(e, t);
  let r = new bt("0.0.0");
  if (e.test(r) || (r = new bt("0.0.0-0"), e.test(r)))
    return r;
  r = null;
  for (let n = 0; n < e.set.length; ++n) {
    const i = e.set[n];
    let s = null;
    i.forEach((o) => {
      const a = new bt(o.semver.version);
      switch (o.operator) {
        case ">":
          a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), a.raw = a.format();
        case "":
        case ">=":
          (!s || Br(a, s)) && (s = a);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${o.operator}`);
      }
    }), s && (!r || Br(r, s)) && (r = s);
  }
  return r && e.test(r) ? r : null;
};
var Eo = go;
const mo = ae(), $o = (e, t) => {
  try {
    return new mo(e, t).range || "*";
  } catch {
    return null;
  }
};
var vo = $o;
const yo = re, Nn = ut(), { ANY: Ro } = Nn, Ao = ae(), wo = ft, Fr = ct, Mr = zt, So = Yt, _o = Wt, bo = (e, t, r, n) => {
  e = new yo(e, n), t = new Ao(t, n);
  let i, s, o, a, l;
  switch (r) {
    case ">":
      i = Fr, s = So, o = Mr, a = ">", l = ">=";
      break;
    case "<":
      i = Mr, s = _o, o = Fr, a = "<", l = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (wo(e, t, n))
    return !1;
  for (let u = 0; u < t.set.length; ++u) {
    const c = t.set[u];
    let g = null, d = null;
    if (c.forEach((h) => {
      h.semver === Ro && (h = new Nn(">=0.0.0")), g = g || h, d = d || h, i(h.semver, g.semver, n) ? g = h : o(h.semver, d.semver, n) && (d = h);
    }), g.operator === a || g.operator === l || (!d.operator || d.operator === a) && s(e, d.semver))
      return !1;
    if (d.operator === l && o(e, d.semver))
      return !1;
  }
  return !0;
};
var Zt = bo;
const Oo = Zt, To = (e, t, r) => Oo(e, t, ">", r);
var Io = To;
const xo = Zt, No = (e, t, r) => xo(e, t, "<", r);
var Co = No;
const Ur = ae(), Lo = (e, t, r) => (e = new Ur(e, r), t = new Ur(t, r), e.intersects(t));
var Po = Lo;
const Do = ft, Ho = oe;
var jo = (e, t, r) => {
  const n = [];
  let i = null, s = null;
  const o = e.sort((c, g) => Ho(c, g, r));
  for (const c of o)
    Do(c, t, r) ? (s = c, i || (i = c)) : (s && n.push([i, s]), s = null, i = null);
  i && n.push([i, null]);
  const a = [];
  for (const [c, g] of n)
    c === g ? a.push(c) : !g && c === o[0] ? a.push("*") : g ? c === o[0] ? a.push(`<=${g}`) : a.push(`${c} - ${g}`) : a.push(`>=${c}`);
  const l = a.join(" || "), u = typeof t.raw == "string" ? t.raw : String(t);
  return l.length < u.length ? l : t;
};
const kr = ae(), Ye = ut(), { ANY: Ot } = Ye, De = ft, Qt = oe, Go = (e, t, r = {}) => {
  if (e === t)
    return !0;
  e = new kr(e, r), t = new kr(t, r);
  let n = !1;
  e: for (const i of e.set) {
    for (const s of t.set) {
      const o = Bo(i, s, r);
      if (n = n || o !== null, o)
        continue e;
    }
    if (n)
      return !1;
  }
  return !0;
}, Bo = (e, t, r) => {
  if (e === t)
    return !0;
  if (e.length === 1 && e[0].semver === Ot) {
    if (t.length === 1 && t[0].semver === Ot)
      return !0;
    r.includePrerelease ? e = [new Ye(">=0.0.0-0")] : e = [new Ye(">=0.0.0")];
  }
  if (t.length === 1 && t[0].semver === Ot) {
    if (r.includePrerelease)
      return !0;
    t = [new Ye(">=0.0.0")];
  }
  const n = /* @__PURE__ */ new Set();
  let i, s;
  for (const h of e)
    h.operator === ">" || h.operator === ">=" ? i = Vr(i, h, r) : h.operator === "<" || h.operator === "<=" ? s = Xr(s, h, r) : n.add(h.semver);
  if (n.size > 1)
    return null;
  let o;
  if (i && s) {
    if (o = Qt(i.semver, s.semver, r), o > 0)
      return null;
    if (o === 0 && (i.operator !== ">=" || s.operator !== "<="))
      return null;
  }
  for (const h of n) {
    if (i && !De(h, String(i), r) || s && !De(h, String(s), r))
      return null;
    for (const S of t)
      if (!De(h, String(S), r))
        return !1;
    return !0;
  }
  let a, l, u, c, g = s && !r.includePrerelease && s.semver.prerelease.length ? s.semver : !1, d = i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
  g && g.prerelease.length === 1 && s.operator === "<" && g.prerelease[0] === 0 && (g = !1);
  for (const h of t) {
    if (c = c || h.operator === ">" || h.operator === ">=", u = u || h.operator === "<" || h.operator === "<=", i) {
      if (d && h.semver.prerelease && h.semver.prerelease.length && h.semver.major === d.major && h.semver.minor === d.minor && h.semver.patch === d.patch && (d = !1), h.operator === ">" || h.operator === ">=") {
        if (a = Vr(i, h, r), a === h && a !== i)
          return !1;
      } else if (i.operator === ">=" && !De(i.semver, String(h), r))
        return !1;
    }
    if (s) {
      if (g && h.semver.prerelease && h.semver.prerelease.length && h.semver.major === g.major && h.semver.minor === g.minor && h.semver.patch === g.patch && (g = !1), h.operator === "<" || h.operator === "<=") {
        if (l = Xr(s, h, r), l === h && l !== s)
          return !1;
      } else if (s.operator === "<=" && !De(s.semver, String(h), r))
        return !1;
    }
    if (!h.operator && (s || i) && o !== 0)
      return !1;
  }
  return !(i && u && !s && o !== 0 || s && c && !i && o !== 0 || d || g);
}, Vr = (e, t, r) => {
  if (!e)
    return t;
  const n = Qt(e.semver, t.semver, r);
  return n > 0 ? e : n < 0 || t.operator === ">" && e.operator === ">=" ? t : e;
}, Xr = (e, t, r) => {
  if (!e)
    return t;
  const n = Qt(e.semver, t.semver, r);
  return n < 0 ? e : n > 0 || t.operator === "<" && e.operator === "<=" ? t : e;
};
var Fo = Go;
const Tt = Ce, Mo = ot, Uo = re, qr = On, ko = Le, Vo = Ms, Xo = Vs, qo = qs, Ko = Qs, zo = ti, Wo = si, Yo = ai, Zo = ui, Qo = oe, Jo = hi, ea = Ei, ta = Kt, ra = yi, na = wi, sa = ct, ia = zt, oa = qt, aa = Tn, la = Wt, ca = Yt, ua = In, fa = Vi, pa = ut(), ha = ae(), da = ft, ga = so, Ea = lo, ma = po, $a = Eo, va = vo, ya = Zt, Ra = Io, Aa = Co, wa = Po, Sa = jo, _a = Fo;
var ee = {
  parse: ko,
  valid: Vo,
  clean: Xo,
  inc: qo,
  diff: Ko,
  major: zo,
  minor: Wo,
  patch: Yo,
  prerelease: Zo,
  compare: Qo,
  rcompare: Jo,
  compareLoose: ea,
  compareBuild: ta,
  sort: ra,
  rsort: na,
  gt: sa,
  lt: ia,
  eq: oa,
  neq: aa,
  gte: la,
  lte: ca,
  cmp: ua,
  coerce: fa,
  Comparator: pa,
  Range: ha,
  satisfies: da,
  toComparators: ga,
  maxSatisfying: Ea,
  minSatisfying: ma,
  minVersion: $a,
  validRange: va,
  outside: ya,
  gtr: Ra,
  ltr: Aa,
  intersects: wa,
  simplifyRange: Sa,
  subset: _a,
  SemVer: Uo,
  re: Tt.re,
  src: Tt.src,
  tokens: Tt.t,
  SEMVER_SPEC_VERSION: Mo.SEMVER_SPEC_VERSION,
  compareIdentifiers: qr.compareIdentifiers,
  rcompareIdentifiers: qr.rcompareIdentifiers
};
const ba = [
  [1e3, 6e4, "sec"],
  [6e4, 36e5, "min"],
  [36e5, 864e5, "hour"],
  [864e5, 6048e5, "day"],
  [6048e5, 2628e6, "week"],
  [2628e6, 31536e6, "month"],
  [31536e6, 1 / 0, "year"]
], Oa = {
  "1 day ago": "yesterday",
  "1 week ago": "last week",
  "1 month ago": "last month",
  "1 year ago": "last year",
  "in 1 day": "tomorrow",
  "in 1 week": "next week",
  "in 1 month": "next month",
  "in 1 year": "next year"
}, Ta = {
  sec: "second",
  min: "minute"
};
function Kr(e) {
  return e instanceof Date ? e.getTime() : typeof e == "string" ? Date.parse(e) : e;
}
function zr(e, { now: t, noAffix: r = !1, times: n = ba, nowThreshold: i = 2e3, nowString: s = "now", unknownString: o = "", aliases: a = !1, aliasesMap: l = Oa, longUnits: u = !1 } = {}) {
  const c = Kr(e);
  if (t = t !== void 0 ? Kr(t) : Date.now(), Number.isNaN(c)) return o || String(e);
  let g = !1, d = t - c;
  if (d < 0 && (g = !0, d = Math.abs(d)), d < i) return s;
  let h = 0, S = "";
  for (let R = 0, I = n.length; R < I; R++) {
    const C = n[R];
    if (!(d >= C[1])) {
      h = Math.floor(d / C[0]), S = (u && Ta[C[2]] || C[2]) + (h > 1 ? "s" : "");
      break;
    }
  }
  const N = `${g && !r ? "in " : ""}${h} ${S}${!g && !r ? " ago" : ""}`;
  return a ? l[N] ?? N : N;
}
function se(e, t = globalThis.Deno ? globalThis.Deno.args : kt.argv) {
  const r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
  return n !== -1 && (i === -1 || n < i);
}
const { env: z } = kt;
let Je;
se("no-color") || se("no-colors") || se("color=false") || se("color=never") ? Je = 0 : (se("color") || se("colors") || se("color=true") || se("color=always")) && (Je = 1);
function Ia() {
  if ("FORCE_COLOR" in z)
    return z.FORCE_COLOR === "true" ? 1 : z.FORCE_COLOR === "false" ? 0 : z.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(z.FORCE_COLOR, 10), 3);
}
function xa(e) {
  return e === 0 ? !1 : {
    level: e,
    hasBasic: !0,
    has256: e >= 2,
    has16m: e >= 3
  };
}
function Na(e, { streamIsTTY: t, sniffFlags: r = !0 } = {}) {
  const n = Ia();
  n !== void 0 && (Je = n);
  const i = r ? Je : n;
  if (i === 0)
    return 0;
  if (r) {
    if (se("color=16m") || se("color=full") || se("color=truecolor"))
      return 3;
    if (se("color=256"))
      return 2;
  }
  if ("TF_BUILD" in z && "AGENT_NAME" in z)
    return 1;
  if (e && !t && i === void 0)
    return 0;
  const s = i || 0;
  if (z.TERM === "dumb")
    return s;
  if (kt.platform === "win32") {
    const o = ns.release().split(".");
    return Number(o[0]) >= 10 && Number(o[2]) >= 10586 ? Number(o[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in z)
    return "GITHUB_ACTIONS" in z || "GITEA_ACTIONS" in z ? 3 : ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((o) => o in z) || z.CI_NAME === "codeship" ? 1 : s;
  if ("TEAMCITY_VERSION" in z)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(z.TEAMCITY_VERSION) ? 1 : 0;
  if (z.COLORTERM === "truecolor" || z.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in z) {
    const o = Number.parseInt((z.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (z.TERM_PROGRAM) {
      case "iTerm.app":
        return o >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(z.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(z.TERM) || "COLORTERM" in z ? 1 : s;
}
function Wr(e, t = {}) {
  const r = Na(e, {
    streamIsTTY: e && e.isTTY,
    ...t
  });
  return xa(r);
}
const Ca = {
  stdout: Wr({ isTTY: fr.isatty(1) }),
  stderr: Wr({ isTTY: fr.isatty(2) })
};
let Cn = !0;
function La() {
  Cn = !1;
}
function Jt(e, t, r) {
  const n = e.join(" ");
  return Cn ? `\x1B[${t}m${n}\x1B[${r}m` : n;
}
const er = (...e) => Jt(e, 31, 39), tr = (...e) => Jt(e, 32, 39), Pa = (...e) => Jt(e, 35, 39);
class Da extends Error {
  constructor(t) {
    super(), this.name = "AbortError", this.message = t;
  }
}
const Yr = (e) => globalThis.DOMException === void 0 ? new Da(e) : new DOMException(e), Zr = (e) => {
  const t = e.reason === void 0 ? Yr("This operation was aborted.") : e.reason;
  return t instanceof Error ? t : Yr(t);
};
async function Ha(e, t, {
  concurrency: r = Number.POSITIVE_INFINITY,
  stopOnError: n = !0,
  signal: i
} = {}) {
  return new Promise((s, o) => {
    if (e[Symbol.iterator] === void 0 && e[Symbol.asyncIterator] === void 0)
      throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof e})`);
    if (typeof t != "function")
      throw new TypeError("Mapper function is required");
    if (!((Number.isSafeInteger(r) || r === Number.POSITIVE_INFINITY) && r >= 1))
      throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${r}\` (${typeof r})`);
    const a = [], l = [], u = /* @__PURE__ */ new Map();
    let c = !1, g = !1, d = !1, h = 0, S = 0;
    const N = e[Symbol.iterator] === void 0 ? e[Symbol.asyncIterator]() : e[Symbol.iterator](), R = (C) => {
      c = !0, g = !0, o(C);
    };
    i && (i.aborted && R(Zr(i)), i.addEventListener("abort", () => {
      R(Zr(i));
    }));
    const I = async () => {
      if (g)
        return;
      const C = await N.next(), y = S;
      if (S++, C.done) {
        if (d = !0, h === 0 && !g) {
          if (!n && l.length > 0) {
            R(new AggregateError(l));
            return;
          }
          if (g = !0, u.size === 0) {
            s(a);
            return;
          }
          const T = [];
          for (const [D, U] of a.entries())
            u.get(D) !== Qr && T.push(U);
          s(T);
        }
        return;
      }
      h++, (async () => {
        try {
          const T = await C.value;
          if (g)
            return;
          const D = await t(T, y);
          D === Qr && u.set(y, D), a[y] = D, h--, await I();
        } catch (T) {
          if (n)
            R(T);
          else {
            l.push(T), h--;
            try {
              await I();
            } catch (D) {
              R(D);
            }
          }
        }
      })();
    };
    (async () => {
      for (let C = 0; C < r; C++) {
        try {
          await I();
        } catch (y) {
          R(y);
          break;
        }
        if (d || c)
          break;
      }
    })();
  });
}
const Qr = Symbol("skip");
async function Jr(e, t) {
  return Ha(e, (r) => r(), t);
}
var Fe = {};
const ce = "\\\\/", en = `[^${ce}]`, de = "\\.", ja = "\\+", Ga = "\\?", pt = "\\/", Ba = "(?=.)", Ln = "[^/]", rr = `(?:${pt}|$)`, Pn = `(?:^|${pt})`, nr = `${de}{1,2}${rr}`, Fa = `(?!${de})`, Ma = `(?!${Pn}${nr})`, Ua = `(?!${de}{0,1}${rr})`, ka = `(?!${nr})`, Va = `[^.${pt}]`, Xa = `${Ln}*?`, qa = "/", Dn = {
  DOT_LITERAL: de,
  PLUS_LITERAL: ja,
  QMARK_LITERAL: Ga,
  SLASH_LITERAL: pt,
  ONE_CHAR: Ba,
  QMARK: Ln,
  END_ANCHOR: rr,
  DOTS_SLASH: nr,
  NO_DOT: Fa,
  NO_DOTS: Ma,
  NO_DOT_SLASH: Ua,
  NO_DOTS_SLASH: ka,
  QMARK_NO_DOT: Va,
  STAR: Xa,
  START_ANCHOR: Pn,
  SEP: qa
}, Ka = {
  ...Dn,
  SLASH_LITERAL: `[${ce}]`,
  QMARK: en,
  STAR: `${en}*?`,
  DOTS_SLASH: `${de}{1,2}(?:[${ce}]|$)`,
  NO_DOT: `(?!${de})`,
  NO_DOTS: `(?!(?:^|[${ce}])${de}{1,2}(?:[${ce}]|$))`,
  NO_DOT_SLASH: `(?!${de}{0,1}(?:[${ce}]|$))`,
  NO_DOTS_SLASH: `(?!${de}{1,2}(?:[${ce}]|$))`,
  QMARK_NO_DOT: `[^.${ce}]`,
  START_ANCHOR: `(?:^|[${ce}])`,
  END_ANCHOR: `(?:[${ce}]|$)`,
  SEP: "\\"
}, za = {
  alnum: "a-zA-Z0-9",
  alpha: "a-zA-Z",
  ascii: "\\x00-\\x7F",
  blank: " \\t",
  cntrl: "\\x00-\\x1F\\x7F",
  digit: "0-9",
  graph: "\\x21-\\x7E",
  lower: "a-z",
  print: "\\x20-\\x7E ",
  punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
  space: " \\t\\r\\n\\v\\f",
  upper: "A-Z",
  word: "A-Za-z0-9_",
  xdigit: "A-Fa-f0-9"
};
var ht = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: za,
  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    "***": "*",
    "**/**": "**",
    "**/**/**": "**"
  },
  // Digits
  CHAR_0: 48,
  /* 0 */
  CHAR_9: 57,
  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: 65,
  /* A */
  CHAR_LOWERCASE_A: 97,
  /* a */
  CHAR_UPPERCASE_Z: 90,
  /* Z */
  CHAR_LOWERCASE_Z: 122,
  /* z */
  CHAR_LEFT_PARENTHESES: 40,
  /* ( */
  CHAR_RIGHT_PARENTHESES: 41,
  /* ) */
  CHAR_ASTERISK: 42,
  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38,
  /* & */
  CHAR_AT: 64,
  /* @ */
  CHAR_BACKWARD_SLASH: 92,
  /* \ */
  CHAR_CARRIAGE_RETURN: 13,
  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94,
  /* ^ */
  CHAR_COLON: 58,
  /* : */
  CHAR_COMMA: 44,
  /* , */
  CHAR_DOT: 46,
  /* . */
  CHAR_DOUBLE_QUOTE: 34,
  /* " */
  CHAR_EQUAL: 61,
  /* = */
  CHAR_EXCLAMATION_MARK: 33,
  /* ! */
  CHAR_FORM_FEED: 12,
  /* \f */
  CHAR_FORWARD_SLASH: 47,
  /* / */
  CHAR_GRAVE_ACCENT: 96,
  /* ` */
  CHAR_HASH: 35,
  /* # */
  CHAR_HYPHEN_MINUS: 45,
  /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60,
  /* < */
  CHAR_LEFT_CURLY_BRACE: 123,
  /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91,
  /* [ */
  CHAR_LINE_FEED: 10,
  /* \n */
  CHAR_NO_BREAK_SPACE: 160,
  /* \u00A0 */
  CHAR_PERCENT: 37,
  /* % */
  CHAR_PLUS: 43,
  /* + */
  CHAR_QUESTION_MARK: 63,
  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62,
  /* > */
  CHAR_RIGHT_CURLY_BRACE: 125,
  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93,
  /* ] */
  CHAR_SEMICOLON: 59,
  /* ; */
  CHAR_SINGLE_QUOTE: 39,
  /* ' */
  CHAR_SPACE: 32,
  /*   */
  CHAR_TAB: 9,
  /* \t */
  CHAR_UNDERSCORE: 95,
  /* _ */
  CHAR_VERTICAL_LINE: 124,
  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
  /* \uFEFF */
  /**
   * Create EXTGLOB_CHARS
   */
  extglobChars(e) {
    return {
      "!": { type: "negate", open: "(?:(?!(?:", close: `))${e.STAR})` },
      "?": { type: "qmark", open: "(?:", close: ")?" },
      "+": { type: "plus", open: "(?:", close: ")+" },
      "*": { type: "star", open: "(?:", close: ")*" },
      "@": { type: "at", open: "(?:", close: ")" }
    };
  },
  /**
   * Create GLOB_CHARS
   */
  globChars(e) {
    return e === !0 ? Ka : Dn;
  }
};
(function(e) {
  const {
    REGEX_BACKSLASH: t,
    REGEX_REMOVE_BACKSLASH: r,
    REGEX_SPECIAL_CHARS: n,
    REGEX_SPECIAL_CHARS_GLOBAL: i
  } = ht;
  e.isObject = (s) => s !== null && typeof s == "object" && !Array.isArray(s), e.hasRegexChars = (s) => n.test(s), e.isRegexChar = (s) => s.length === 1 && e.hasRegexChars(s), e.escapeRegex = (s) => s.replace(i, "\\$1"), e.toPosixSlashes = (s) => s.replace(t, "/"), e.isWindows = () => {
    if (typeof navigator < "u" && navigator.platform) {
      const s = navigator.platform.toLowerCase();
      return s === "win32" || s === "windows";
    }
    return typeof process < "u" && process.platform ? process.platform === "win32" : !1;
  }, e.removeBackslashes = (s) => s.replace(r, (o) => o === "\\" ? "" : o), e.escapeLast = (s, o, a) => {
    const l = s.lastIndexOf(o, a);
    return l === -1 ? s : s[l - 1] === "\\" ? e.escapeLast(s, o, l - 1) : `${s.slice(0, l)}\\${s.slice(l)}`;
  }, e.removePrefix = (s, o = {}) => {
    let a = s;
    return a.startsWith("./") && (a = a.slice(2), o.prefix = "./"), a;
  }, e.wrapOutput = (s, o = {}, a = {}) => {
    const l = a.contains ? "" : "^", u = a.contains ? "" : "$";
    let c = `${l}(?:${s})${u}`;
    return o.negated === !0 && (c = `(?:^(?!${c}).*$)`), c;
  }, e.basename = (s, { windows: o } = {}) => {
    const a = s.split(o ? /[\\/]/ : "/"), l = a[a.length - 1];
    return l === "" ? a[a.length - 2] : l;
  };
})(Fe);
const tn = Fe, {
  CHAR_ASTERISK: It,
  /* * */
  CHAR_AT: Wa,
  /* @ */
  CHAR_BACKWARD_SLASH: He,
  /* \ */
  CHAR_COMMA: Ya,
  /* , */
  CHAR_DOT: xt,
  /* . */
  CHAR_EXCLAMATION_MARK: Nt,
  /* ! */
  CHAR_FORWARD_SLASH: Hn,
  /* / */
  CHAR_LEFT_CURLY_BRACE: Ct,
  /* { */
  CHAR_LEFT_PARENTHESES: Lt,
  /* ( */
  CHAR_LEFT_SQUARE_BRACKET: Za,
  /* [ */
  CHAR_PLUS: Qa,
  /* + */
  CHAR_QUESTION_MARK: rn,
  /* ? */
  CHAR_RIGHT_CURLY_BRACE: Ja,
  /* } */
  CHAR_RIGHT_PARENTHESES: nn,
  /* ) */
  CHAR_RIGHT_SQUARE_BRACKET: el
  /* ] */
} = ht, sn = (e) => e === Hn || e === He, on = (e) => {
  e.isPrefix !== !0 && (e.depth = e.isGlobstar ? 1 / 0 : 1);
}, tl = (e, t) => {
  const r = t || {}, n = e.length - 1, i = r.parts === !0 || r.scanToEnd === !0, s = [], o = [], a = [];
  let l = e, u = -1, c = 0, g = 0, d = !1, h = !1, S = !1, N = !1, R = !1, I = !1, C = !1, y = !1, T = !1, D = !1, U = 0, H, P, L = { value: "", depth: 0, isGlob: !1 };
  const E = () => u >= n, w = () => l.charCodeAt(u + 1), $ = () => (H = P, l.charCodeAt(++u));
  for (; u < n; ) {
    P = $();
    let v;
    if (P === He) {
      C = L.backslashes = !0, P = $(), P === Ct && (I = !0);
      continue;
    }
    if (I === !0 || P === Ct) {
      for (U++; E() !== !0 && (P = $()); ) {
        if (P === He) {
          C = L.backslashes = !0, $();
          continue;
        }
        if (P === Ct) {
          U++;
          continue;
        }
        if (I !== !0 && P === xt && (P = $()) === xt) {
          if (d = L.isBrace = !0, S = L.isGlob = !0, D = !0, i === !0)
            continue;
          break;
        }
        if (I !== !0 && P === Ya) {
          if (d = L.isBrace = !0, S = L.isGlob = !0, D = !0, i === !0)
            continue;
          break;
        }
        if (P === Ja && (U--, U === 0)) {
          I = !1, d = L.isBrace = !0, D = !0;
          break;
        }
      }
      if (i === !0)
        continue;
      break;
    }
    if (P === Hn) {
      if (s.push(u), o.push(L), L = { value: "", depth: 0, isGlob: !1 }, D === !0) continue;
      if (H === xt && u === c + 1) {
        c += 2;
        continue;
      }
      g = u + 1;
      continue;
    }
    if (r.noext !== !0 && (P === Qa || P === Wa || P === It || P === rn || P === Nt) === !0 && w() === Lt) {
      if (S = L.isGlob = !0, N = L.isExtglob = !0, D = !0, P === Nt && u === c && (T = !0), i === !0) {
        for (; E() !== !0 && (P = $()); ) {
          if (P === He) {
            C = L.backslashes = !0, P = $();
            continue;
          }
          if (P === nn) {
            S = L.isGlob = !0, D = !0;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (P === It) {
      if (H === It && (R = L.isGlobstar = !0), S = L.isGlob = !0, D = !0, i === !0)
        continue;
      break;
    }
    if (P === rn) {
      if (S = L.isGlob = !0, D = !0, i === !0)
        continue;
      break;
    }
    if (P === Za) {
      for (; E() !== !0 && (v = $()); ) {
        if (v === He) {
          C = L.backslashes = !0, $();
          continue;
        }
        if (v === el) {
          h = L.isBracket = !0, S = L.isGlob = !0, D = !0;
          break;
        }
      }
      if (i === !0)
        continue;
      break;
    }
    if (r.nonegate !== !0 && P === Nt && u === c) {
      y = L.negated = !0, c++;
      continue;
    }
    if (r.noparen !== !0 && P === Lt) {
      if (S = L.isGlob = !0, i === !0) {
        for (; E() !== !0 && (P = $()); ) {
          if (P === Lt) {
            C = L.backslashes = !0, P = $();
            continue;
          }
          if (P === nn) {
            D = !0;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (S === !0) {
      if (D = !0, i === !0)
        continue;
      break;
    }
  }
  r.noext === !0 && (N = !1, S = !1);
  let b = l, f = "", p = "";
  c > 0 && (f = l.slice(0, c), l = l.slice(c), g -= c), b && S === !0 && g > 0 ? (b = l.slice(0, g), p = l.slice(g)) : S === !0 ? (b = "", p = l) : b = l, b && b !== "" && b !== "/" && b !== l && sn(b.charCodeAt(b.length - 1)) && (b = b.slice(0, -1)), r.unescape === !0 && (p && (p = tn.removeBackslashes(p)), b && C === !0 && (b = tn.removeBackslashes(b)));
  const m = {
    prefix: f,
    input: e,
    start: c,
    base: b,
    glob: p,
    isBrace: d,
    isBracket: h,
    isGlob: S,
    isExtglob: N,
    isGlobstar: R,
    negated: y,
    negatedExtglob: T
  };
  if (r.tokens === !0 && (m.maxDepth = 0, sn(P) || o.push(L), m.tokens = o), r.parts === !0 || r.tokens === !0) {
    let v;
    for (let A = 0; A < s.length; A++) {
      const x = v ? v + 1 : c, j = s[A], q = e.slice(x, j);
      r.tokens && (A === 0 && c !== 0 ? (o[A].isPrefix = !0, o[A].value = f) : o[A].value = q, on(o[A]), m.maxDepth += o[A].depth), (A !== 0 || q !== "") && a.push(q), v = j;
    }
    if (v && v + 1 < e.length) {
      const A = e.slice(v + 1);
      a.push(A), r.tokens && (o[o.length - 1].value = A, on(o[o.length - 1]), m.maxDepth += o[o.length - 1].depth);
    }
    m.slashes = s, m.parts = a;
  }
  return m;
};
var rl = tl;
const et = ht, ue = Fe, {
  MAX_LENGTH: tt,
  POSIX_REGEX_SOURCE: nl,
  REGEX_NON_SPECIAL_CHARS: sl,
  REGEX_SPECIAL_CHARS_BACKREF: il,
  REPLACEMENTS: jn
} = et, ol = (e, t) => {
  if (typeof t.expandRange == "function")
    return t.expandRange(...e, t);
  e.sort();
  const r = `[${e.join("-")}]`;
  try {
    new RegExp(r);
  } catch {
    return e.map((i) => ue.escapeRegex(i)).join("..");
  }
  return r;
}, Oe = (e, t) => `Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`, sr = (e, t) => {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  e = jn[e] || e;
  const r = { ...t }, n = typeof r.maxLength == "number" ? Math.min(tt, r.maxLength) : tt;
  let i = e.length;
  if (i > n)
    throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${n}`);
  const s = { type: "bos", value: "", output: r.prepend || "" }, o = [s], a = r.capture ? "" : "?:", l = et.globChars(r.windows), u = et.extglobChars(l), {
    DOT_LITERAL: c,
    PLUS_LITERAL: g,
    SLASH_LITERAL: d,
    ONE_CHAR: h,
    DOTS_SLASH: S,
    NO_DOT: N,
    NO_DOT_SLASH: R,
    NO_DOTS_SLASH: I,
    QMARK: C,
    QMARK_NO_DOT: y,
    STAR: T,
    START_ANCHOR: D
  } = l, U = (O) => `(${a}(?:(?!${D}${O.dot ? S : c}).)*?)`, H = r.dot ? "" : N, P = r.dot ? C : y;
  let L = r.bash === !0 ? U(r) : T;
  r.capture && (L = `(${L})`), typeof r.noext == "boolean" && (r.noextglob = r.noext);
  const E = {
    input: e,
    index: -1,
    start: 0,
    dot: r.dot === !0,
    consumed: "",
    output: "",
    prefix: "",
    backtrack: !1,
    negated: !1,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: !1,
    tokens: o
  };
  e = ue.removePrefix(e, E), i = e.length;
  const w = [], $ = [], b = [];
  let f = s, p;
  const m = () => E.index === i - 1, v = E.peek = (O = 1) => e[E.index + O], A = E.advance = () => e[++E.index] || "", x = () => e.slice(E.index + 1), j = (O = "", V = 0) => {
    E.consumed += O, E.index += V;
  }, q = (O) => {
    E.output += O.output != null ? O.output : O.value, j(O.value);
  }, X = () => {
    let O = 1;
    for (; v() === "!" && (v(2) !== "(" || v(3) === "?"); )
      A(), E.start++, O++;
    return O % 2 === 0 ? !1 : (E.negated = !0, E.start++, !0);
  }, Z = (O) => {
    E[O]++, b.push(O);
  }, Y = (O) => {
    E[O]--, b.pop();
  }, G = (O) => {
    if (f.type === "globstar") {
      const V = E.braces > 0 && (O.type === "comma" || O.type === "brace"), _ = O.extglob === !0 || w.length && (O.type === "pipe" || O.type === "paren");
      O.type !== "slash" && O.type !== "paren" && !V && !_ && (E.output = E.output.slice(0, -f.output.length), f.type = "star", f.value = "*", f.output = L, E.output += f.output);
    }
    if (w.length && O.type !== "paren" && (w[w.length - 1].inner += O.value), (O.value || O.output) && q(O), f && f.type === "text" && O.type === "text") {
      f.output = (f.output || f.value) + O.value, f.value += O.value;
      return;
    }
    O.prev = f, o.push(O), f = O;
  }, Ee = (O, V) => {
    const _ = { ...u[V], conditions: 1, inner: "" };
    _.prev = f, _.parens = E.parens, _.output = E.output;
    const F = (r.capture ? "(" : "") + _.open;
    Z("parens"), G({ type: O, value: V, output: E.output ? "" : h }), G({ type: "paren", extglob: !0, value: A(), output: F }), w.push(_);
  }, ne = (O) => {
    let V = O.close + (r.capture ? ")" : ""), _;
    if (O.type === "negate") {
      let F = L;
      if (O.inner && O.inner.length > 1 && O.inner.includes("/") && (F = U(r)), (F !== L || m() || /^\)+$/.test(x())) && (V = O.close = `)$))${F}`), O.inner.includes("*") && (_ = x()) && /^\.[^\\/.]+$/.test(_)) {
        const K = sr(_, { ...t, fastpaths: !1 }).output;
        V = O.close = `)${K})${F})`;
      }
      O.prev.type === "bos" && (E.negatedExtglob = !0);
    }
    G({ type: "paren", extglob: !0, value: p, output: V }), Y("parens");
  };
  if (r.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(e)) {
    let O = !1, V = e.replace(il, (_, F, K, te, Q, gt) => te === "\\" ? (O = !0, _) : te === "?" ? F ? F + te + (Q ? C.repeat(Q.length) : "") : gt === 0 ? P + (Q ? C.repeat(Q.length) : "") : C.repeat(K.length) : te === "." ? c.repeat(K.length) : te === "*" ? F ? F + te + (Q ? L : "") : L : F ? _ : `\\${_}`);
    return O === !0 && (r.unescape === !0 ? V = V.replace(/\\/g, "") : V = V.replace(/\\+/g, (_) => _.length % 2 === 0 ? "\\\\" : _ ? "\\" : "")), V === e && r.contains === !0 ? (E.output = e, E) : (E.output = ue.wrapOutput(V, E, t), E);
  }
  for (; !m(); ) {
    if (p = A(), p === "\0")
      continue;
    if (p === "\\") {
      const _ = v();
      if (_ === "/" && r.bash !== !0 || _ === "." || _ === ";")
        continue;
      if (!_) {
        p += "\\", G({ type: "text", value: p });
        continue;
      }
      const F = /^\\+/.exec(x());
      let K = 0;
      if (F && F[0].length > 2 && (K = F[0].length, E.index += K, K % 2 !== 0 && (p += "\\")), r.unescape === !0 ? p = A() : p += A(), E.brackets === 0) {
        G({ type: "text", value: p });
        continue;
      }
    }
    if (E.brackets > 0 && (p !== "]" || f.value === "[" || f.value === "[^")) {
      if (r.posix !== !1 && p === ":") {
        const _ = f.value.slice(1);
        if (_.includes("[") && (f.posix = !0, _.includes(":"))) {
          const F = f.value.lastIndexOf("["), K = f.value.slice(0, F), te = f.value.slice(F + 2), Q = nl[te];
          if (Q) {
            f.value = K + Q, E.backtrack = !0, A(), !s.output && o.indexOf(f) === 1 && (s.output = h);
            continue;
          }
        }
      }
      (p === "[" && v() !== ":" || p === "-" && v() === "]") && (p = `\\${p}`), p === "]" && (f.value === "[" || f.value === "[^") && (p = `\\${p}`), r.posix === !0 && p === "!" && f.value === "[" && (p = "^"), f.value += p, q({ value: p });
      continue;
    }
    if (E.quotes === 1 && p !== '"') {
      p = ue.escapeRegex(p), f.value += p, q({ value: p });
      continue;
    }
    if (p === '"') {
      E.quotes = E.quotes === 1 ? 0 : 1, r.keepQuotes === !0 && G({ type: "text", value: p });
      continue;
    }
    if (p === "(") {
      Z("parens"), G({ type: "paren", value: p });
      continue;
    }
    if (p === ")") {
      if (E.parens === 0 && r.strictBrackets === !0)
        throw new SyntaxError(Oe("opening", "("));
      const _ = w[w.length - 1];
      if (_ && E.parens === _.parens + 1) {
        ne(w.pop());
        continue;
      }
      G({ type: "paren", value: p, output: E.parens ? ")" : "\\)" }), Y("parens");
      continue;
    }
    if (p === "[") {
      if (r.nobracket === !0 || !x().includes("]")) {
        if (r.nobracket !== !0 && r.strictBrackets === !0)
          throw new SyntaxError(Oe("closing", "]"));
        p = `\\${p}`;
      } else
        Z("brackets");
      G({ type: "bracket", value: p });
      continue;
    }
    if (p === "]") {
      if (r.nobracket === !0 || f && f.type === "bracket" && f.value.length === 1) {
        G({ type: "text", value: p, output: `\\${p}` });
        continue;
      }
      if (E.brackets === 0) {
        if (r.strictBrackets === !0)
          throw new SyntaxError(Oe("opening", "["));
        G({ type: "text", value: p, output: `\\${p}` });
        continue;
      }
      Y("brackets");
      const _ = f.value.slice(1);
      if (f.posix !== !0 && _[0] === "^" && !_.includes("/") && (p = `/${p}`), f.value += p, q({ value: p }), r.literalBrackets === !1 || ue.hasRegexChars(_))
        continue;
      const F = ue.escapeRegex(f.value);
      if (E.output = E.output.slice(0, -f.value.length), r.literalBrackets === !0) {
        E.output += F, f.value = F;
        continue;
      }
      f.value = `(${a}${F}|${f.value})`, E.output += f.value;
      continue;
    }
    if (p === "{" && r.nobrace !== !0) {
      Z("braces");
      const _ = {
        type: "brace",
        value: p,
        output: "(",
        outputIndex: E.output.length,
        tokensIndex: E.tokens.length
      };
      $.push(_), G(_);
      continue;
    }
    if (p === "}") {
      const _ = $[$.length - 1];
      if (r.nobrace === !0 || !_) {
        G({ type: "text", value: p, output: p });
        continue;
      }
      let F = ")";
      if (_.dots === !0) {
        const K = o.slice(), te = [];
        for (let Q = K.length - 1; Q >= 0 && (o.pop(), K[Q].type !== "brace"); Q--)
          K[Q].type !== "dots" && te.unshift(K[Q].value);
        F = ol(te, r), E.backtrack = !0;
      }
      if (_.comma !== !0 && _.dots !== !0) {
        const K = E.output.slice(0, _.outputIndex), te = E.tokens.slice(_.tokensIndex);
        _.value = _.output = "\\{", p = F = "\\}", E.output = K;
        for (const Q of te)
          E.output += Q.output || Q.value;
      }
      G({ type: "brace", value: p, output: F }), Y("braces"), $.pop();
      continue;
    }
    if (p === "|") {
      w.length > 0 && w[w.length - 1].conditions++, G({ type: "text", value: p });
      continue;
    }
    if (p === ",") {
      let _ = p;
      const F = $[$.length - 1];
      F && b[b.length - 1] === "braces" && (F.comma = !0, _ = "|"), G({ type: "comma", value: p, output: _ });
      continue;
    }
    if (p === "/") {
      if (f.type === "dot" && E.index === E.start + 1) {
        E.start = E.index + 1, E.consumed = "", E.output = "", o.pop(), f = s;
        continue;
      }
      G({ type: "slash", value: p, output: d });
      continue;
    }
    if (p === ".") {
      if (E.braces > 0 && f.type === "dot") {
        f.value === "." && (f.output = c);
        const _ = $[$.length - 1];
        f.type = "dots", f.output += p, f.value += p, _.dots = !0;
        continue;
      }
      if (E.braces + E.parens === 0 && f.type !== "bos" && f.type !== "slash") {
        G({ type: "text", value: p, output: c });
        continue;
      }
      G({ type: "dot", value: p, output: c });
      continue;
    }
    if (p === "?") {
      if (!(f && f.value === "(") && r.noextglob !== !0 && v() === "(" && v(2) !== "?") {
        Ee("qmark", p);
        continue;
      }
      if (f && f.type === "paren") {
        const F = v();
        let K = p;
        (f.value === "(" && !/[!=<:]/.test(F) || F === "<" && !/<([!=]|\w+>)/.test(x())) && (K = `\\${p}`), G({ type: "text", value: p, output: K });
        continue;
      }
      if (r.dot !== !0 && (f.type === "slash" || f.type === "bos")) {
        G({ type: "qmark", value: p, output: y });
        continue;
      }
      G({ type: "qmark", value: p, output: C });
      continue;
    }
    if (p === "!") {
      if (r.noextglob !== !0 && v() === "(" && (v(2) !== "?" || !/[!=<:]/.test(v(3)))) {
        Ee("negate", p);
        continue;
      }
      if (r.nonegate !== !0 && E.index === 0) {
        X();
        continue;
      }
    }
    if (p === "+") {
      if (r.noextglob !== !0 && v() === "(" && v(2) !== "?") {
        Ee("plus", p);
        continue;
      }
      if (f && f.value === "(" || r.regex === !1) {
        G({ type: "plus", value: p, output: g });
        continue;
      }
      if (f && (f.type === "bracket" || f.type === "paren" || f.type === "brace") || E.parens > 0) {
        G({ type: "plus", value: p });
        continue;
      }
      G({ type: "plus", value: g });
      continue;
    }
    if (p === "@") {
      if (r.noextglob !== !0 && v() === "(" && v(2) !== "?") {
        G({ type: "at", extglob: !0, value: p, output: "" });
        continue;
      }
      G({ type: "text", value: p });
      continue;
    }
    if (p !== "*") {
      (p === "$" || p === "^") && (p = `\\${p}`);
      const _ = sl.exec(x());
      _ && (p += _[0], E.index += _[0].length), G({ type: "text", value: p });
      continue;
    }
    if (f && (f.type === "globstar" || f.star === !0)) {
      f.type = "star", f.star = !0, f.value += p, f.output = L, E.backtrack = !0, E.globstar = !0, j(p);
      continue;
    }
    let O = x();
    if (r.noextglob !== !0 && /^\([^?]/.test(O)) {
      Ee("star", p);
      continue;
    }
    if (f.type === "star") {
      if (r.noglobstar === !0) {
        j(p);
        continue;
      }
      const _ = f.prev, F = _.prev, K = _.type === "slash" || _.type === "bos", te = F && (F.type === "star" || F.type === "globstar");
      if (r.bash === !0 && (!K || O[0] && O[0] !== "/")) {
        G({ type: "star", value: p, output: "" });
        continue;
      }
      const Q = E.braces > 0 && (_.type === "comma" || _.type === "brace"), gt = w.length && (_.type === "pipe" || _.type === "paren");
      if (!K && _.type !== "paren" && !Q && !gt) {
        G({ type: "star", value: p, output: "" });
        continue;
      }
      for (; O.slice(0, 3) === "/**"; ) {
        const ke = e[E.index + 4];
        if (ke && ke !== "/")
          break;
        O = O.slice(3), j("/**", 3);
      }
      if (_.type === "bos" && m()) {
        f.type = "globstar", f.value += p, f.output = U(r), E.output = f.output, E.globstar = !0, j(p);
        continue;
      }
      if (_.type === "slash" && _.prev.type !== "bos" && !te && m()) {
        E.output = E.output.slice(0, -(_.output + f.output).length), _.output = `(?:${_.output}`, f.type = "globstar", f.output = U(r) + (r.strictSlashes ? ")" : "|$)"), f.value += p, E.globstar = !0, E.output += _.output + f.output, j(p);
        continue;
      }
      if (_.type === "slash" && _.prev.type !== "bos" && O[0] === "/") {
        const ke = O[1] !== void 0 ? "|$" : "";
        E.output = E.output.slice(0, -(_.output + f.output).length), _.output = `(?:${_.output}`, f.type = "globstar", f.output = `${U(r)}${d}|${d}${ke})`, f.value += p, E.output += _.output + f.output, E.globstar = !0, j(p + A()), G({ type: "slash", value: "/", output: "" });
        continue;
      }
      if (_.type === "bos" && O[0] === "/") {
        f.type = "globstar", f.value += p, f.output = `(?:^|${d}|${U(r)}${d})`, E.output = f.output, E.globstar = !0, j(p + A()), G({ type: "slash", value: "/", output: "" });
        continue;
      }
      E.output = E.output.slice(0, -f.output.length), f.type = "globstar", f.output = U(r), f.value += p, E.output += f.output, E.globstar = !0, j(p);
      continue;
    }
    const V = { type: "star", value: p, output: L };
    if (r.bash === !0) {
      V.output = ".*?", (f.type === "bos" || f.type === "slash") && (V.output = H + V.output), G(V);
      continue;
    }
    if (f && (f.type === "bracket" || f.type === "paren") && r.regex === !0) {
      V.output = p, G(V);
      continue;
    }
    (E.index === E.start || f.type === "slash" || f.type === "dot") && (f.type === "dot" ? (E.output += R, f.output += R) : r.dot === !0 ? (E.output += I, f.output += I) : (E.output += H, f.output += H), v() !== "*" && (E.output += h, f.output += h)), G(V);
  }
  for (; E.brackets > 0; ) {
    if (r.strictBrackets === !0) throw new SyntaxError(Oe("closing", "]"));
    E.output = ue.escapeLast(E.output, "["), Y("brackets");
  }
  for (; E.parens > 0; ) {
    if (r.strictBrackets === !0) throw new SyntaxError(Oe("closing", ")"));
    E.output = ue.escapeLast(E.output, "("), Y("parens");
  }
  for (; E.braces > 0; ) {
    if (r.strictBrackets === !0) throw new SyntaxError(Oe("closing", "}"));
    E.output = ue.escapeLast(E.output, "{"), Y("braces");
  }
  if (r.strictSlashes !== !0 && (f.type === "star" || f.type === "bracket") && G({ type: "maybe_slash", value: "", output: `${d}?` }), E.backtrack === !0) {
    E.output = "";
    for (const O of E.tokens)
      E.output += O.output != null ? O.output : O.value, O.suffix && (E.output += O.suffix);
  }
  return E;
};
sr.fastpaths = (e, t) => {
  const r = { ...t }, n = typeof r.maxLength == "number" ? Math.min(tt, r.maxLength) : tt, i = e.length;
  if (i > n)
    throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${n}`);
  e = jn[e] || e;
  const {
    DOT_LITERAL: s,
    SLASH_LITERAL: o,
    ONE_CHAR: a,
    DOTS_SLASH: l,
    NO_DOT: u,
    NO_DOTS: c,
    NO_DOTS_SLASH: g,
    STAR: d,
    START_ANCHOR: h
  } = et.globChars(r.windows), S = r.dot ? c : u, N = r.dot ? g : u, R = r.capture ? "" : "?:", I = { negated: !1, prefix: "" };
  let C = r.bash === !0 ? ".*?" : d;
  r.capture && (C = `(${C})`);
  const y = (H) => H.noglobstar === !0 ? C : `(${R}(?:(?!${h}${H.dot ? l : s}).)*?)`, T = (H) => {
    switch (H) {
      case "*":
        return `${S}${a}${C}`;
      case ".*":
        return `${s}${a}${C}`;
      case "*.*":
        return `${S}${C}${s}${a}${C}`;
      case "*/*":
        return `${S}${C}${o}${a}${N}${C}`;
      case "**":
        return S + y(r);
      case "**/*":
        return `(?:${S}${y(r)}${o})?${N}${a}${C}`;
      case "**/*.*":
        return `(?:${S}${y(r)}${o})?${N}${C}${s}${a}${C}`;
      case "**/.*":
        return `(?:${S}${y(r)}${o})?${s}${a}${C}`;
      default: {
        const P = /^(.*?)\.(\w+)$/.exec(H);
        if (!P) return;
        const L = T(P[1]);
        return L ? L + s + P[2] : void 0;
      }
    }
  }, D = ue.removePrefix(e, I);
  let U = T(D);
  return U && r.strictSlashes !== !0 && (U += `${o}?`), U;
};
var al = sr;
const ll = rl, Gt = al, Gn = Fe, cl = ht, ul = (e) => e && typeof e == "object" && !Array.isArray(e), W = (e, t, r = !1) => {
  if (Array.isArray(e)) {
    const c = e.map((d) => W(d, t, r));
    return (d) => {
      for (const h of c) {
        const S = h(d);
        if (S) return S;
      }
      return !1;
    };
  }
  const n = ul(e) && e.tokens && e.input;
  if (e === "" || typeof e != "string" && !n)
    throw new TypeError("Expected pattern to be a non-empty string");
  const i = t || {}, s = i.windows, o = n ? W.compileRe(e, t) : W.makeRe(e, t, !1, !0), a = o.state;
  delete o.state;
  let l = () => !1;
  if (i.ignore) {
    const c = { ...t, ignore: null, onMatch: null, onResult: null };
    l = W(i.ignore, c, r);
  }
  const u = (c, g = !1) => {
    const { isMatch: d, match: h, output: S } = W.test(c, o, t, { glob: e, posix: s }), N = { glob: e, state: a, regex: o, posix: s, input: c, output: S, match: h, isMatch: d };
    return typeof i.onResult == "function" && i.onResult(N), d === !1 ? (N.isMatch = !1, g ? N : !1) : l(c) ? (typeof i.onIgnore == "function" && i.onIgnore(N), N.isMatch = !1, g ? N : !1) : (typeof i.onMatch == "function" && i.onMatch(N), g ? N : !0);
  };
  return r && (u.state = a), u;
};
W.test = (e, t, r, { glob: n, posix: i } = {}) => {
  if (typeof e != "string")
    throw new TypeError("Expected input to be a string");
  if (e === "")
    return { isMatch: !1, output: "" };
  const s = r || {}, o = s.format || (i ? Gn.toPosixSlashes : null);
  let a = e === n, l = a && o ? o(e) : e;
  return a === !1 && (l = o ? o(e) : e, a = l === n), (a === !1 || s.capture === !0) && (s.matchBase === !0 || s.basename === !0 ? a = W.matchBase(e, t, r, i) : a = t.exec(l)), { isMatch: !!a, match: a, output: l };
};
W.matchBase = (e, t, r) => (t instanceof RegExp ? t : W.makeRe(t, r)).test(Gn.basename(e));
W.isMatch = (e, t, r) => W(t, r)(e);
W.parse = (e, t) => Array.isArray(e) ? e.map((r) => W.parse(r, t)) : Gt(e, { ...t, fastpaths: !1 });
W.scan = (e, t) => ll(e, t);
W.compileRe = (e, t, r = !1, n = !1) => {
  if (r === !0)
    return e.output;
  const i = t || {}, s = i.contains ? "" : "^", o = i.contains ? "" : "$";
  let a = `${s}(?:${e.output})${o}`;
  e && e.negated === !0 && (a = `^(?!${a}).*$`);
  const l = W.toRegex(a, t);
  return n === !0 && (l.state = e), l;
};
W.makeRe = (e, t = {}, r = !1, n = !1) => {
  if (!e || typeof e != "string")
    throw new TypeError("Expected a non-empty string");
  let i = { negated: !1, fastpaths: !0 };
  return t.fastpaths !== !1 && (e[0] === "." || e[0] === "*") && (i.output = Gt.fastpaths(e, t)), i.output || (i = Gt(e, t)), W.compileRe(i, t, r, n);
};
W.toRegex = (e, t) => {
  try {
    const r = t || {};
    return new RegExp(e, r.flags || (r.nocase ? "i" : ""));
  } catch (r) {
    if (t && t.debug === !0) throw r;
    return /$^/;
  }
};
W.constants = cl;
var fl = W;
const Bn = fl, pl = Fe;
function Fn(e, t, r = !1) {
  return t && (t.windows === null || t.windows === void 0) && (t = { ...t, windows: pl.isWindows() }), Bn(e, t, r);
}
Object.assign(Fn, Bn);
var hl = Fn;
const an = /* @__PURE__ */ st(hl), dl = "updates", gl = "16.4.0", El = "Flexible npm and poetry dependency update tool", ml = "silverwind", $l = "silverwind/updates", vl = "BSD-2-Clause", yl = "dist/index.js", Rl = "dist/index.d.ts", Al = "module", wl = [
  "dist"
], Sl = {
  node: ">=18"
}, _l = {
  "@types/minimist": "1.2.5",
  "@types/node": "22.10.1",
  "@types/picomatch": "3.0.1",
  "@types/rc": "1.2.4",
  "@types/registry-auth-token": "4.2.4",
  "@types/semver": "7.5.8",
  "ansi-regex": "6.1.0",
  eslint: "8.57.0",
  "eslint-config-silverwind": "96.0.6",
  execa: "8.0.1",
  glowie: "1.3.2",
  minimist: "1.2.8",
  "p-all": "5.0.0",
  picomatch: "4.0.2",
  rc: "1.2.8",
  "registry-auth-token": "4.2.2",
  restana: "4.9.9",
  semver: "7.3.8",
  "smol-toml": "1.3.1",
  "supports-color": "9.4.0",
  timerel: "5.8.1",
  typescript: "5.7.2",
  "typescript-config-silverwind": "6.2.0",
  versions: "12.1.2",
  vite: "5.4.11",
  "vite-config-silverwind": "3.1.0",
  "vite-plugin-dts": "3.9.1",
  vitest: "2.1.8",
  "vitest-config-silverwind": "9.2.0"
}, bl = {
  name: dl,
  version: gl,
  description: El,
  author: ml,
  repository: $l,
  license: vl,
  bin: yl,
  types: Rl,
  type: Al,
  files: wl,
  engines: Sl,
  devDependencies: _l
}, Ol = /^.*?:\/\/(.*?@)?(github\.com[:/])/i, Tl = /^([^/]+)\/([^/#]+)?.*?\/([0-9a-f]+|v?[0-9]+\.[0-9]+\.[0-9]+)$/i, Bt = /^[0-9a-f]{7,}$/i, ln = /[0-9]+(\.[0-9]+)?(\.[0-9]+)?/g, rt = (e) => e.replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&"), Me = (e) => e.endsWith("/") ? e.substring(0, e.length - 1) : e, Mn = bl.version, fe = "\0", Ft = {
  "package.json": "npm",
  "pyproject.toml": "pypi",
  "go.mod": "go"
}, M = as(Zn.slice(2), {
  boolean: [
    "E",
    "error-on-outdated",
    "U",
    "error-on-unchanged",
    "h",
    "help",
    "j",
    "json",
    "n",
    "no-color",
    "u",
    "update",
    "v",
    "version",
    "V",
    "verbose"
  ],
  string: [
    "d",
    "allow-downgrade",
    "f",
    "file",
    "g",
    "greatest",
    "m",
    "minor",
    "M",
    "modes",
    "P",
    "patch",
    "p",
    "prerelease",
    "R",
    "release",
    "r",
    "registry",
    "t",
    "types",
    "githubapi",
    // undocumented, only for tests
    "pypiapi",
    // undocumented, only for tests
    "goproxy"
    // undocumented, only for tests
  ],
  alias: {
    d: "allow-downgrade",
    E: "error-on-outdated",
    U: "error-on-unchanged",
    e: "exclude",
    f: "file",
    g: "greatest",
    h: "help",
    i: "include",
    j: "json",
    m: "minor",
    M: "modes",
    n: "no-color",
    P: "patch",
    p: "prerelease",
    r: "registry",
    R: "release",
    s: "semver",
    S: "sockets",
    t: "types",
    u: "update",
    v: "version",
    V: "verbose"
  }
});
(M["no-color"] || !Ca.stdout) && La();
const Te = Ue($e(M.greatest)), Pt = Ue($e(M.prerelease)), Dt = Ue($e(M.release)), cn = Ue($e(M.patch)), un = Ue($e(M.minor)), fn = $e(M["allow-downgrade"]), Il = $e(M.modes) || /* @__PURE__ */ new Set(["npm", "pypi"]), Un = M.githubapi ? Me(M.githubapi) : "https://api.github.com", xl = M.pypiapi ? Me(M.pypiapi) : "https://pypi.org", Nl = "https://proxy.golang.org", Cl = M.goproxy ? Me(M.goproxy) : Pl(), xe = (e) => e.replace(/^v/, "");
function ye(e, t) {
  for (const r of t instanceof Set ? t : [])
    if (r.test(e)) return !0;
  return !1;
}
function Ll(e, t) {
  const r = t[`${e}:registry`] || t.registry;
  return r.endsWith("/") ? r : `${r}/`;
}
function Pl() {
  return Ie.GOPROXY ? Ie.GOPROXY.split(/[,|]/).map((e) => e.trim()).filter((e) => !!e && e !== "direct") : [Nl];
}
function Dl(e, t) {
  return t.split(".").reduce((r, n) => r?.[n] ?? null, e);
}
function Ze(e) {
  return e.split(",").filter(Boolean);
}
function kn(e, t) {
  const r = Xt(t, e);
  try {
    return rs(r), r;
  } catch {
  }
  const n = Vt(t);
  return n === t ? null : kn(e, n);
}
function Hl(e, t, r, n) {
  if (e.startsWith("@")) {
    const i = (/@[a-z0-9][\w-.]+/.exec(e) || [""])[0], s = Me(Ll(i, n));
    if (s !== t)
      try {
        const o = yt(s, r);
        if (o?.token) return { auth: o, registry: s };
      } catch {
      }
    return { auth: yt(t, r), registry: t };
  } else
    return { auth: yt(t, r), registry: t };
}
function ir(e, t, r) {
  return {
    ...Object.keys(e).length && { agentOpts: e },
    headers: {
      "user-agent": `updates/${Mn}`,
      ...r && { Authorization: `${t} ${r}` }
    }
  };
}
async function dt(e, t) {
  M.verbose && console.error(`${Pa("fetch")} ${e}`);
  const r = await fetch(e, t);
  return M.verbose && console.error(`${r.ok ? tr(r.status) : er(r.status)} ${e}`), r;
}
async function jl(e, t, r, n, i, s) {
  const { auth: o, registry: a } = Hl(e, r, i, s), l = t === "resolutions" ? We(e) : e, u = `${a}/${l.replace(/\//g, "%2f")}`, c = await dt(u, ir(n, o?.type, o?.token));
  if (c?.ok)
    return [await c.json(), t, a, e];
  throw c?.status && c?.statusText ? new Error(`Received ${c.status} ${c.statusText} from ${u}`) : new Error(`Unable to fetch ${e} from ${a}`);
}
async function Gl(e, t, r) {
  const n = `${xl}/pypi/${e}/json`, i = await dt(n, ir(r));
  if (i?.ok)
    return [await i.json(), t, null, e];
  throw i?.status && i?.statusText ? new Error(`Received ${i.status} ${i.statusText} from ${n}`) : new Error(`Unable to fetch ${e} from PyPi`);
}
function Bl(e) {
  return e.split(/\r?\n/).map((t) => t.trim()).filter(Boolean);
}
async function Vn(e, t, r, n) {
  const i = n.shift();
  if (!i)
    throw new Error("No more go proxies available");
  const s = `${i}/${e.toLowerCase()}/@latest`, o = await dt(s, ir(r));
  if ([404, 410].includes(o.status) && n.length)
    return Vn(e, t, r, n);
  if (o?.ok)
    return o.json();
  throw o?.status && o?.statusText ? new Error(`Received ${o.status} ${o.statusText} from ${s}`) : new Error(`Unable to fetch ${e} from PyPi`);
}
function Fl(e) {
  return e = e.replace("git@", "").replace(/.+?\/\//, "https://").replace(/\.git$/, ""), /^[a-z]+:[a-z0-9-]\/[a-z0-9-]$/.test(e) ? e.replace(/^(.+?):/, (t, r) => `https://${r}.com/`) : /^[a-z0-9-]\/[a-z0-9-]$/.test(e) ? `https://github.com/${e}` : e;
}
function Ml(e) {
  return e.startsWith("https://bitbucket.org") ? "src/HEAD" : "tree/HEAD";
}
function pn({ repository: e, homepage: t, info: r }, n, i) {
  r && (e = r.project_urls.repository || r.project_urls.Repository || r.project_urls.repo || r.project_urls.Repo || r.project_urls.source || r.project_urls.Source || r.project_urls["source code"] || r.project_urls["Source Code"] || r.project_urls.homepage || r.project_urls.Homepage || `https://pypi.org/project/${i}/`);
  let s = "";
  if (n === "https://npm.pkg.github.com")
    return `https://github.com/${i.replace(/^@/, "")}`;
  if (e) {
    const o = typeof e == "string" ? e : e.url;
    s = Fl(o), s && typeof e != "string" && e.directory && (s = `${s}/${Ml(s)}/${e.directory}`);
  }
  return s || t || "";
}
function hn(e) {
  console.info(M.json ? JSON.stringify({ message: e }) : e), Ge();
}
function Ge(e) {
  if (e) {
    const t = e.stack ?? e.message;
    console.info(M.json ? JSON.stringify({ error: t }) : er(t));
  }
  process.exit(e ? 1 : 0);
}
function Ul(e = {}) {
  for (const r of Object.keys(e))
    for (const n of Object.values(e[r]))
      typeof n.oldPrint == "string" && (n.old = n.oldPrint, delete n.oldPrint), typeof n.newPrint == "string" && (n.new = n.newPrint, delete n.newPrint), typeof n.oldOriginal == "string" && (n.old = n.oldOriginal, delete n.oldOriginal);
  let t = 0;
  for (const r of Object.keys(e))
    t += Object.keys(e[r]).length;
  if (M.json) {
    const r = { results: {} };
    for (const n of Object.keys(e))
      for (const [i, s] of Object.entries(e[n])) {
        const [o, a] = i.split(fe);
        r.results[n] || (r.results[n] = {}), r.results[n][o] || (r.results[n][o] = {}), r.results[n][o][a] = s;
      }
    console.info(JSON.stringify(r));
  } else t && console.info(ql(e));
  return M["error-on-outdated"] ? t ? 2 : 0 : M["error-on-unchanged"] ? t ? 0 : 2 : 0;
}
async function kl(e, t) {
  const { platform: r } = await import("node:os"), n = r() === "win32";
  n && es(e, 0), ts(e, t, n ? { flag: "r+" } : void 0);
}
function dn(e, t, r) {
  if (e === t) return e;
  const n = e.split(/\./), i = t.split(/\./), s = /^[0-9a-zA-Z-.]+$/;
  let o = "";
  for (let a = 0; a < n.length; a++)
    if (n[a] !== i[a]) {
      s.test(n[a]) ? o += r(n.slice(a).join(".")) : o += n[a].split("").map((l) => s.test(l) ? r(l) : l).join("") + r(`.${n.slice(a + 1).join(".")}`.replace(/\.$/, ""));
      break;
    } else
      o += `${n[a]}.`;
  return o.replace(/\.$/, "");
}
const gn = (e) => e.replace(is(), "").length;
function Vl(e, t = " ") {
  let r = "";
  const n = new Array(e[0].length).fill(0);
  for (const i of e)
    for (const [s, o] of i.entries()) {
      const a = gn(o);
      a > n[s] && (n[s] = a);
    }
  for (const [i, s] of e.entries()) {
    for (const [o, a] of s.entries()) {
      o > 0 && (r += t);
      const l = " ".repeat(n[o] - gn(a));
      r += a + (o === s.length - 1 ? "" : l);
    }
    i < e.length - 1 && (r += `
`);
  }
  return r;
}
function Xl(e) {
  return /\/v[0-9]$/.test(e) && (e = Vt(e)), e;
}
function ql(e) {
  const t = [["NAME", "OLD", "NEW", "AGE", "INFO"]], r = /* @__PURE__ */ new Set();
  for (const n of Object.keys(e))
    for (const [i, s] of Object.entries(e[n])) {
      const o = i.split(fe)[1], a = `${n}|${o}`;
      r.has(a) || (r.add(a), t.push([
        n === "go" ? Xl(o) : o,
        dn(s.old, s.new, er),
        dn(s.new, s.old, tr),
        s.age || "",
        s.info || ""
      ]));
    }
  return Vl(t);
}
function Kl(e, t) {
  let r = e;
  for (const n of Object.keys(t)) {
    const i = n.split(fe)[1], s = t[n].oldOriginal || t[n].old, o = new RegExp(`"${rt(i)}": *"${rt(s)}"`, "g");
    r = r.replace(o, `"${i}": "${t[n].new}"`);
  }
  return r;
}
function zl(e, t) {
  let r = e;
  for (const n of Object.keys(t)) {
    const i = n.split(fe)[1], s = t[n].oldOriginal || t[n].old, o = new RegExp(`${rt(i)} *= *"${rt(s)}"`, "g");
    r = r.replace(o, `${i} = "${t[n].new}"`);
  }
  return r;
}
function Wl(e, t, r) {
  let n = e.replace(/[0-9]+\.[0-9]+\.[0-9]+(-.+)?/g, t);
  if (r && r !== e && /^[\^~]/.test(n)) {
    const i = r.substring(1).split("."), s = n.substring(1).split(".");
    i.length !== s.length && (n = `${n[0]}${s.slice(0, i.length).join(".")}`);
  }
  return n;
}
function Ht(e) {
  const t = ee.parse(e);
  return t ? !!t.prerelease.length : !1;
}
function Xn(e) {
  return /[0-9]+\.[0-9]+\.[0-9]+-.+/.test(e);
}
function Be(e) {
  try {
    return ee.coerce(e)?.version ?? "";
  } catch {
    return "";
  }
}
function Yl(e, t, { range: r, semvers: n, usePre: i, useRel: s, useGreatest: o }) {
  let a = Be(r), l = 0;
  i = Xn(r) || i, i && (n.add("prerelease"), n.has("patch") && n.add("prepatch"), n.has("minor") && n.add("preminor"), n.has("major") && n.add("premajor"));
  for (const u of t) {
    const c = ee.parse(u);
    if (!c || !a || c.prerelease.length && (!i || s)) continue;
    const g = ee.diff(a, c.version);
    if (!(!g || !n.has(g)))
      if (o || !("time" in e))
        ee.gte(Be(c?.version), a) && (a = c.version);
      else {
        const d = new Date(e.time[u]).getTime();
        d >= 0 && d > l && (a = c.version, l = d);
      }
  }
  return a || null;
}
function Zl(e, { mode: t, range: r, useGreatest: n, useRel: i, usePre: s, semvers: o }) {
  if (t === "go")
    return ee.gt(xe(e.Version), xe(r)) ? e.Version : null;
  if (r === "*" || r.includes("||")) return null;
  let a = [];
  t === "pypi" ? a = Object.keys(e.releases).filter((u) => ee.valid(u)) : t === "npm" && (a = Object.keys(e.versions).filter((u) => ee.valid(u)));
  const l = Yl(e, a, { range: r, semvers: o, usePre: s, useRel: i, useGreatest: n });
  if (!l) return null;
  if (n)
    return l;
  {
    let u = "", c = "";
    t === "pypi" ? (c = e.info.version, u = Be(e.info.version)) : u = e["dist-tags"].latest;
    const g = Be(r), d = Xn(r), h = Ht(l), S = Ht(u), N = ee.gt(l, g);
    if (!i && s || d && h || i && !N && d && !h || d && !h && N)
      return l;
    if (d && !h && !N)
      return null;
    const R = ee.diff(g, u);
    return R && R !== "prerelease" && !o.has(R.replace(/^pre/, "")) || i && Ht(u) ? l : ee.lt(u, g) && !S ? fn === !0 || ye(e.name, fn) ? u : null : c || u;
  }
}
function qn(e) {
  const t = {}, r = Ie.UPDATES_GITHUB_API_TOKEN || Ie.GITHUB_API_TOKEN || Ie.GH_TOKEN || Ie.HOMEBREW_GITHUB_API_TOKEN;
  return r && (t.headers = { Authorization: `Bearer ${r}` }), dt(e, t);
}
async function Ql(e, t) {
  const r = `${Un}/repos/${e}/${t}/commits`, n = await qn(r);
  if (!n?.ok) return { hash: "", commit: {} };
  const i = await n.json(), { sha: s, commit: o } = i[0];
  return { hash: s, commit: o };
}
async function Jl(e, t) {
  const r = await qn(`${Un}/repos/${e}/${t}/git/refs/tags`);
  return r?.ok ? (await r.json()).map((s) => s.ref.replace(/^refs\/tags\//, "")) : [];
}
function ec(e, t, r) {
  const n = xe(t);
  if (ee.valid(n))
    if (r) {
      let i = t, s = xe(t);
      for (const o of e) {
        const a = xe(o);
        ee.valid(a) && (!i || ee.gt(a, s)) && (i = o, s = a);
      }
      if (ee.neq(n, s))
        return i;
    } else {
      const i = e.at(-1);
      if (!i) return;
      const s = xe(i);
      if (!ee.valid(s)) return;
      if (ee.neq(n, s))
        return i;
    }
}
async function tc(e, t, r) {
  const n = t.old.replace(Ol, ""), [i, s, o, a] = Tl.exec(n) || [];
  if (!(!s || !o || !a))
    if (Bt.test(a)) {
      const { hash: l, commit: u } = await Ql(s, o);
      if (!l) return;
      const c = u?.committer?.date ?? u?.author?.date, g = l.substring(0, a.length);
      if (a !== g) {
        const d = t.old.replace(a, g);
        return { key: e, newRange: d, user: s, repo: o, oldRef: a, newRef: g, newDate: c };
      }
    } else {
      const l = await Jl(s, o), u = ec(l, a, r);
      if (u)
        return { key: e, newRange: u, user: s, repo: o, oldRef: a, newRef: u };
    }
}
function rc(e) {
  return e.replace(/-.*/, "");
}
function nc(e) {
  const t = e.match(ln);
  return t?.length !== 1 ? e : e.replace(ln, Be(t[0]));
}
function $e(e) {
  return e === void 0 ? !1 : e === "" ? !0 : typeof e == "string" ? e.includes(",") ? new Set(Ze(e)) : /* @__PURE__ */ new Set([e]) : Array.isArray(e) ? new Set(e) : !1;
}
function sc(e) {
  return Array.from(e.matchAll(/(----BEGIN CERT[^]+?IFICATE----)/g), (t) => t[0]);
}
function ic(e) {
  return Array.from(e.matchAll(/(----BEGIN [^]+?PRIVATE KEY----)/g), (t) => t[0]);
}
async function oc(e = []) {
  return [...(await import("node:tls")).rootCertificates, ...e];
}
function Mt(e, t) {
  return t && typeof e == "string" ? /\/.+\//.test(e) ? new RegExp(e.slice(1, -1)) : an.makeRe(e) : e instanceof RegExp ? e : an.makeRe(e);
}
function Ue(e) {
  if (e instanceof Set) {
    const t = /* @__PURE__ */ new Set();
    for (const r of e)
      t.add(Mt(r, !0));
    return t;
  }
  return e;
}
function En(e, t) {
  const r = /* @__PURE__ */ new Set();
  for (const n of e || [])
    r.add(Mt(n, !0));
  for (const n of t || [])
    r.add(Mt(n, !1));
  return r;
}
function mn(e, t, r, n) {
  if (t === "pypi" && e === "python") return !1;
  if (!r.size && !n.size) return !0;
  for (const i of n)
    if (i.test(e)) return !1;
  for (const i of r)
    if (i.test(e)) return !0;
  return !r.size;
}
function ac(e) {
  const t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
  if (e)
    for (const n of e) {
      let i;
      try {
        i = ur(n);
      } catch (s) {
        throw new Error(`Unable to open ${n}: ${s.message}`);
      }
      if (i?.isFile()) {
        const s = ze(n);
        t.add(s), r.add(s);
      } else if (i?.isDirectory())
        for (const s of Object.keys(Ft)) {
          const o = Xt(n, s);
          let a;
          try {
            a = ur(o);
          } catch {
          }
          a?.isFile() && t.add(ze(o));
        }
      else
        throw new Error(`${n} is neither a file nor directory`);
    }
  else
    for (const n of Object.keys(Ft)) {
      const i = kn(n, Jn());
      i && t.add(ze(i));
    }
  return [t, r];
}
async function lc(e) {
  const t = [];
  for (const n of ["", ".config/"])
    for (const i of ["js", "ts", "mjs", "mts"])
      t.push(`${n}updates${n ? "" : ".config"}.${i}`);
  let r = {};
  try {
    ({ default: r } = await Promise.any(t.map((n) => import(Xt(e, ...n.split("/"))))));
  } catch {
  }
  return r;
}
async function cc() {
  for (const R of [process.stdout, process.stderr])
    R?._handle?.setBlocking?.(!0);
  const e = 96, t = typeof M.sockets == "number" ? M.sockets : e, { help: r, version: n, file: i, types: s, update: o } = M;
  r && (Qn.write(`usage: updates [options]

  Options:
    -u, --update                       Update versions and write package file
    -f, --file <path,...>              File or directory to use, defaults to current directory
    -i, --include <pkg,...>            Include only given packages
    -e, --exclude <pkg,...>            Exclude given packages
    -p, --prerelease [<pkg,...>]       Consider prerelease versions
    -R, --release [<pkg,...>]          Only use release versions, may downgrade
    -g, --greatest [<pkg,...>]         Prefer greatest over latest version
    -t, --types <type,...>             Check only given dependency types
    -P, --patch [<pkg,...>]            Consider only up to semver-patch
    -m, --minor [<pkg,...>]            Consider only up to semver-minor
    -d, --allow-downgrade [<pkg,...>]  Allow version downgrades when using latest version
    -E, --error-on-outdated            Exit with code 2 when updates are available and 0 when not
    -U, --error-on-unchanged           Exit with code 0 when updates are available and 2 when not
    -r, --registry <url>               Override npm registry URL
    -S, --sockets <num>                Maximum number of parallel HTTP sockets opened. Default: ${e}
    -M, --modes <mode,...>             Which modes to enable. Either npm,pypi,go. Default: npm,pypi
    -j, --json                         Output a JSON object
    -n, --no-color                     Disable color output
    -v, --version                      Print the version
    -V, --verbose                      Print verbose output to stderr
    -h, --help                         Print this help

  Examples:
    $ updates
    $ updates -u
    $ updates -e '@vitejs/*'
    $ updates -e '/^react-(dom)?/'
    $ updates -f package.json
    $ updates -f pyproject.toml
`), lr(0)), n && (console.info(Mn), lr(0));
  const a = {}, l = {}, u = {}, c = {};
  let g = 0;
  const [d, h] = ac($e(i));
  for (const R of d) {
    const I = Vt(ze(R)), C = We(R), y = Ft[C];
    if (!Il.has(y) && !h.has(R)) continue;
    c[y] = R, a[y] || (a[y] = {});
    const T = await lc(I);
    let D = [], U = [];
    M.include && M.include !== !0 && (D = (Array.isArray(M.include) ? M.include : [M.include]).flatMap((m) => Ze(m))), M.exclude && M.exclude !== !0 && (U = (Array.isArray(M.exclude) ? M.exclude : [M.exclude]).flatMap((m) => Ze(m)));
    const H = En(D, T?.include ?? []), P = En(U, T?.exclude ?? []), L = {}, E = _s("npm", { registry: "https://registry.npmjs.org" }) || {}, w = { npmrc: E, recursive: !0 };
    if (y === "npm") {
      E["strict-ssl"] === !1 && (L.rejectUnauthorized = !1);
      for (const m of ["cert", "ca", "key"]) {
        const v = m === "key" ? ic : sc;
        let A = [];
        E[m] && (A = (Array.isArray(E[m]) ? E[m] : [E[m]]).flatMap((x) => v(x))), E[`${m}file`] && (A = Array.from(v(cr(E[`opt${R}`], "utf8")))), A.length && (L[m] = m === "ca" ? await oc(A) : A);
      }
    }
    let $ = [];
    s ? $ = Array.isArray(s) ? s : Ze(s) : "types" in T && Array.isArray(T.types) ? $ = T.types : y === "npm" ? $ = [
      "dependencies",
      "devDependencies",
      "optionalDependencies",
      "peerDependencies",
      "resolutions"
    ] : y === "pypi" ? $ = [
      "tool.poetry.dependencies",
      "tool.poetry.dev-dependencies",
      "tool.poetry.test-dependencies",
      "tool.poetry.group.dev.dependencies",
      "tool.poetry.group.test.dependencies"
    ] : y === "go" && ($ = [
      "deps"
    ]);
    let b = {};
    if (y === "go")
      u[y] = ss("go", [
        "list",
        "-m",
        "-f",
        "{{if not .Indirect}}{{.Path}}@{{.Version}}{{end}}",
        "all"
      ], { stdio: "pipe", encoding: "utf8", cwd: I });
    else
      try {
        u[y] = cr(R, "utf8");
      } catch (m) {
        throw new Error(`Unable to open ${R}: ${m.message}`);
      }
    try {
      if (y === "npm")
        b = JSON.parse(u[y]);
      else if (y === "pypi")
        b = (await Promise.resolve().then(() => wc)).parse(u[y]);
      else {
        b.deps = {};
        for (const m of Bl(u[y])) {
          const [v, A] = m.split("@");
          A && (b.deps[v] = A);
        }
      }
    } catch (m) {
      throw new Error(`Error parsing ${R}: ${m.message}`);
    }
    for (const m of $) {
      let v;
      y === "npm" || y === "go" ? v = b[m] || {} : v = Dl(b, m) || {};
      for (const [A, x] of Object.entries(v))
        y !== "go" && ee.validRange(x) && mn(A, y, H, P) ? a[y][`${m}${fe}${A}`] = {
          old: nc(x),
          oldOriginal: x
        } : y === "npm" && mn(A, y, H, P) ? l[`${m}${fe}${A}`] = {
          old: x
        } : y === "go" && (a[y][`${m}${fe}${A}`] = {
          old: rc(x),
          oldOriginal: x
        });
    }
    if (g += Object.keys(a[y]).length + Object.keys(l).length, !g) continue;
    let f;
    y === "npm" && (f = Me(M.registry || T.registry || E.registry));
    const p = await Jr(Object.keys(a[y]).map((m) => async () => {
      const [v, A] = m.split(fe);
      if (y === "npm")
        return jl(A, v, f, L, w, E);
      if (y === "pypi")
        return Gl(A, v, L);
      {
        const x = Array.from(Cl);
        return [await Vn(A, "latest", L, x), "deps", null, A];
      }
    }), { concurrency: t });
    for (const [m, v, A, x] of p) {
      if (m?.error) throw new Error(m.error);
      const j = typeof Te == "boolean" ? Te : ye(m.name, Te), q = typeof Pt == "boolean" ? Pt : ye(m.name, Pt), X = typeof Dt == "boolean" ? Dt : ye(m.name, Dt);
      let Z;
      cn === !0 || ye(m.name, cn) ? Z = /* @__PURE__ */ new Set(["patch"]) : un === !0 || ye(m.name, un) ? Z = /* @__PURE__ */ new Set(["patch", "minor"]) : Z = /* @__PURE__ */ new Set(["patch", "minor", "major"]);
      const Y = `${v}${fe}${x}`, G = a[y][Y].old, Ee = a[y][Y].oldOriginal, ne = Zl(m, {
        usePre: q,
        useRel: X,
        useGreatest: j,
        semvers: Z,
        range: G,
        mode: y
      });
      let O = "";
      if (y === "go" && ne ? O = ne : ne && (O = Wl(G, ne, Ee)), !ne || Ee && Ee === O)
        delete a[y][Y];
      else {
        a[y][Y].new = O, y === "npm" ? a[y][Y].info = pn(m?.versions?.[ne], A, m.name) : y === "pypi" ? a[y][Y].info = pn(m, A, m.info.name) : a[y][Y].info = m?.Origin?.URL ?? `https://${x}`;
        let V = "";
        y === "npm" && m.time?.[ne] ? V = m.time[ne] : y === "pypi" && m.releases?.[ne]?.[0]?.upload_time_iso_8601 ? V = m.releases[ne][0].upload_time_iso_8601 : y === "go" && m.Time && (V = m.Time), V && (a[y][Y].age = zr(V, { noAffix: !0 }));
      }
    }
    if (Object.keys(l).length) {
      const m = await Jr(Object.entries(l).map(([v, A]) => () => {
        const x = v.split(fe)[1], j = typeof Te == "boolean" ? Te : ye(x, Te);
        return tc(v, A, j);
      }), { concurrency: t });
      for (const v of (m || []).filter(Boolean)) {
        const { key: A, newRange: x, user: j, repo: q, oldRef: X, newRef: Z, newDate: Y } = v;
        a[y][A] = {
          // @ts-expect-error
          old: l[A].old,
          new: x,
          oldPrint: Bt.test(X) ? X.substring(0, 7) : X,
          newPrint: Bt.test(Z) ? Z.substring(0, 7) : Z,
          info: `https://github.com/${j}/${q}`,
          ...Y ? { age: zr(Y, { noAffix: !0 }) } : {}
        };
      }
    }
  }
  g === 0 && (hn("No dependencies found, nothing to do."), Ge());
  let S = 0;
  for (const R of Object.keys(a))
    S += Object.keys(a[R]).length;
  S || (hn("All dependencies are up to date."), Ge());
  const N = Ul(a);
  if (o) {
    for (const R of Object.keys(a))
      if (Object.keys(a[R]).length) {
        try {
          const I = R === "npm" ? Kl : zl;
          await kl(c[R], I(u[R], a[R]));
        } catch (I) {
          throw new Error(`Error writing ${We(c[R])}: ${I.message}`);
        }
        console.info(tr(`✨ ${We(c[R])} updated`));
      }
  }
  process.exit(N);
}
cc().catch(Ge).then(Ge);
function uc(e, t) {
  let r = e.slice(0, t).split(/\r\n|\n|\r/g);
  return [r.length, r.pop().length + 1];
}
function fc(e, t, r) {
  let n = e.split(/\r\n|\n|\r/g), i = "", s = (Math.log10(t + 1) | 0) + 1;
  for (let o = t - 1; o <= t + 1; o++) {
    let a = n[o - 1];
    a && (i += o.toString().padEnd(s, " "), i += ":  ", i += a, i += `
`, o === t && (i += " ".repeat(s + r + 2), i += `^
`));
  }
  return i;
}
class B extends Error {
  line;
  column;
  codeblock;
  constructor(t, r) {
    const [n, i] = uc(r.toml, r.ptr), s = fc(r.toml, n, i);
    super(`Invalid TOML document: ${t}

${s}`, r), this.line = n, this.column = i, this.codeblock = s;
  }
}
function nt(e, t = 0, r = e.length) {
  let n = e.indexOf(`
`, t);
  return e[n - 1] === "\r" && n--, n <= r ? n : -1;
}
function or(e, t) {
  for (let r = t; r < e.length; r++) {
    let n = e[r];
    if (n === `
`)
      return r;
    if (n === "\r" && e[r + 1] === `
`)
      return r + 1;
    if (n < " " && n !== "	" || n === "")
      throw new B("control characters are not allowed in comments", {
        toml: e,
        ptr: t
      });
  }
  return e.length;
}
function ge(e, t, r, n) {
  let i;
  for (; (i = e[t]) === " " || i === "	" || !r && (i === `
` || i === "\r" && e[t + 1] === `
`); )
    t++;
  return n || i !== "#" ? t : ge(e, or(e, t), r);
}
function $n(e, t, r, n, i = !1) {
  if (!n)
    return t = nt(e, t), t < 0 ? e.length : t;
  for (let s = t; s < e.length; s++) {
    let o = e[s];
    if (o === "#")
      s = nt(e, s);
    else {
      if (o === r)
        return s + 1;
      if (o === n)
        return s;
      if (i && (o === `
` || o === "\r" && e[s + 1] === `
`))
        return s;
    }
  }
  throw new B("cannot find end of structure", {
    toml: e,
    ptr: t
  });
}
function Kn(e, t) {
  let r = e[t], n = r === e[t + 1] && e[t + 1] === e[t + 2] ? e.slice(t, t + 3) : r;
  t += n.length - 1;
  do
    t = e.indexOf(n, ++t);
  while (t > -1 && r !== "'" && e[t - 1] === "\\" && e[t - 2] !== "\\");
  return t > -1 && (t += n.length, n.length > 1 && (e[t] === r && t++, e[t] === r && t++)), t;
}
let pc = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
class we extends Date {
  #t = !1;
  #r = !1;
  #e = null;
  constructor(t) {
    let r = !0, n = !0, i = "Z";
    if (typeof t == "string") {
      let s = t.match(pc);
      s ? (s[1] || (r = !1, t = `0000-01-01T${t}`), n = !!s[2], s[2] && +s[2] > 23 ? t = "" : (i = s[3] || null, t = t.toUpperCase(), !i && n && (t += "Z"))) : t = "";
    }
    super(t), isNaN(this.getTime()) || (this.#t = r, this.#r = n, this.#e = i);
  }
  isDateTime() {
    return this.#t && this.#r;
  }
  isLocal() {
    return !this.#t || !this.#r || !this.#e;
  }
  isDate() {
    return this.#t && !this.#r;
  }
  isTime() {
    return this.#r && !this.#t;
  }
  isValid() {
    return this.#t || this.#r;
  }
  toISOString() {
    let t = super.toISOString();
    if (this.isDate())
      return t.slice(0, 10);
    if (this.isTime())
      return t.slice(11, 23);
    if (this.#e === null)
      return t.slice(0, -1);
    if (this.#e === "Z")
      return t;
    let r = +this.#e.slice(1, 3) * 60 + +this.#e.slice(4, 6);
    return r = this.#e[0] === "-" ? r : -r, new Date(this.getTime() - r * 6e4).toISOString().slice(0, -1) + this.#e;
  }
  static wrapAsOffsetDateTime(t, r = "Z") {
    let n = new we(t);
    return n.#e = r, n;
  }
  static wrapAsLocalDateTime(t) {
    let r = new we(t);
    return r.#e = null, r;
  }
  static wrapAsLocalDate(t) {
    let r = new we(t);
    return r.#r = !1, r.#e = null, r;
  }
  static wrapAsLocalTime(t) {
    let r = new we(t);
    return r.#t = !1, r.#e = null, r;
  }
}
let hc = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/, dc = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/, gc = /^[+-]?0[0-9_]/, Ec = /^[0-9a-f]{4,8}$/i, vn = {
  b: "\b",
  t: "	",
  n: `
`,
  f: "\f",
  r: "\r",
  '"': '"',
  "\\": "\\"
};
function zn(e, t = 0, r = e.length) {
  let n = e[t] === "'", i = e[t++] === e[t] && e[t] === e[t + 1];
  i && (r -= 2, e[t += 2] === "\r" && t++, e[t] === `
` && t++);
  let s = 0, o, a = "", l = t;
  for (; t < r - 1; ) {
    let u = e[t++];
    if (u === `
` || u === "\r" && e[t] === `
`) {
      if (!i)
        throw new B("newlines are not allowed in strings", {
          toml: e,
          ptr: t - 1
        });
    } else if (u < " " && u !== "	" || u === "")
      throw new B("control characters are not allowed in strings", {
        toml: e,
        ptr: t - 1
      });
    if (o) {
      if (o = !1, u === "u" || u === "U") {
        let c = e.slice(t, t += u === "u" ? 4 : 8);
        if (!Ec.test(c))
          throw new B("invalid unicode escape", {
            toml: e,
            ptr: s
          });
        try {
          a += String.fromCodePoint(parseInt(c, 16));
        } catch {
          throw new B("invalid unicode escape", {
            toml: e,
            ptr: s
          });
        }
      } else if (i && (u === `
` || u === " " || u === "	" || u === "\r")) {
        if (t = ge(e, t - 1, !0), e[t] !== `
` && e[t] !== "\r")
          throw new B("invalid escape: only line-ending whitespace may be escaped", {
            toml: e,
            ptr: s
          });
        t = ge(e, t);
      } else if (u in vn)
        a += vn[u];
      else
        throw new B("unrecognized escape sequence", {
          toml: e,
          ptr: s
        });
      l = t;
    } else !n && u === "\\" && (s = t - 1, o = !0, a += e.slice(l, s));
  }
  return a + e.slice(l, r - 1);
}
function mc(e, t, r) {
  if (e === "true")
    return !0;
  if (e === "false")
    return !1;
  if (e === "-inf")
    return -1 / 0;
  if (e === "inf" || e === "+inf")
    return 1 / 0;
  if (e === "nan" || e === "+nan" || e === "-nan")
    return NaN;
  if (e === "-0")
    return 0;
  let n;
  if ((n = hc.test(e)) || dc.test(e)) {
    if (gc.test(e))
      throw new B("leading zeroes are not allowed", {
        toml: t,
        ptr: r
      });
    let s = +e.replace(/_/g, "");
    if (isNaN(s))
      throw new B("invalid number", {
        toml: t,
        ptr: r
      });
    if (n && !Number.isSafeInteger(s))
      throw new B("integer value cannot be represented losslessly", {
        toml: t,
        ptr: r
      });
    return s;
  }
  let i = new we(e);
  if (!i.isValid())
    throw new B("invalid value", {
      toml: t,
      ptr: r
    });
  return i;
}
function $c(e, t, r, n) {
  let i = e.slice(t, r), s = i.indexOf("#");
  s > -1 && (or(e, s), i = i.slice(0, s));
  let o = i.trimEnd();
  if (!n) {
    let a = i.indexOf(`
`, o.length);
    if (a > -1)
      throw new B("newlines are not allowed in inline tables", {
        toml: e,
        ptr: t + a
      });
  }
  return [o, s];
}
function ar(e, t, r, n) {
  if (n === 0)
    throw new B("document contains excessively nested structures. aborting.", {
      toml: e,
      ptr: t
    });
  let i = e[t];
  if (i === "[" || i === "{") {
    let [a, l] = i === "[" ? Rc(e, t, n) : yc(e, t, n), u = $n(e, l, ",", r);
    if (r === "}") {
      let c = nt(e, l, u);
      if (c > -1)
        throw new B("newlines are not allowed in inline tables", {
          toml: e,
          ptr: c
        });
    }
    return [a, u];
  }
  let s;
  if (i === '"' || i === "'") {
    s = Kn(e, t);
    let a = zn(e, t, s);
    if (r) {
      if (s = ge(e, s, r !== "]"), e[s] && e[s] !== "," && e[s] !== r && e[s] !== `
` && e[s] !== "\r")
        throw new B("unexpected character encountered", {
          toml: e,
          ptr: s
        });
      s += +(e[s] === ",");
    }
    return [a, s];
  }
  s = $n(e, t, ",", r);
  let o = $c(e, t, s - +(e[s - 1] === ","), r === "]");
  if (!o[0])
    throw new B("incomplete key-value declaration: no value specified", {
      toml: e,
      ptr: t
    });
  return r && o[1] > -1 && (s = ge(e, t + o[1]), s += +(e[s] === ",")), [
    mc(o[0], e, t),
    s
  ];
}
let vc = /^[a-zA-Z0-9-_]+[ \t]*$/;
function Ut(e, t, r = "=") {
  let n = t - 1, i = [], s = e.indexOf(r, t);
  if (s < 0)
    throw new B("incomplete key-value: cannot find end of key", {
      toml: e,
      ptr: t
    });
  do {
    let o = e[t = ++n];
    if (o !== " " && o !== "	")
      if (o === '"' || o === "'") {
        if (o === e[t + 1] && o === e[t + 2])
          throw new B("multiline strings are not allowed in keys", {
            toml: e,
            ptr: t
          });
        let a = Kn(e, t);
        if (a < 0)
          throw new B("unfinished string encountered", {
            toml: e,
            ptr: t
          });
        n = e.indexOf(".", a);
        let l = e.slice(a, n < 0 || n > s ? s : n), u = nt(l);
        if (u > -1)
          throw new B("newlines are not allowed in keys", {
            toml: e,
            ptr: t + n + u
          });
        if (l.trimStart())
          throw new B("found extra tokens after the string part", {
            toml: e,
            ptr: a
          });
        if (s < a && (s = e.indexOf(r, a), s < 0))
          throw new B("incomplete key-value: cannot find end of key", {
            toml: e,
            ptr: t
          });
        i.push(zn(e, t, a));
      } else {
        n = e.indexOf(".", t);
        let a = e.slice(t, n < 0 || n > s ? s : n);
        if (!vc.test(a))
          throw new B("only letter, numbers, dashes and underscores are allowed in keys", {
            toml: e,
            ptr: t
          });
        i.push(a.trimEnd());
      }
  } while (n + 1 && n < s);
  return [i, ge(e, s + 1, !0, !0)];
}
function yc(e, t, r) {
  let n = {}, i = /* @__PURE__ */ new Set(), s, o = 0;
  for (t++; (s = e[t++]) !== "}" && s; ) {
    if (s === `
`)
      throw new B("newlines are not allowed in inline tables", {
        toml: e,
        ptr: t - 1
      });
    if (s === "#")
      throw new B("inline tables cannot contain comments", {
        toml: e,
        ptr: t - 1
      });
    if (s === ",")
      throw new B("expected key-value, found comma", {
        toml: e,
        ptr: t - 1
      });
    if (s !== " " && s !== "	") {
      let a, l = n, u = !1, [c, g] = Ut(e, t - 1);
      for (let S = 0; S < c.length; S++) {
        if (S && (l = u ? l[a] : l[a] = {}), a = c[S], (u = Object.hasOwn(l, a)) && (typeof l[a] != "object" || i.has(l[a])))
          throw new B("trying to redefine an already defined value", {
            toml: e,
            ptr: t
          });
        !u && a === "__proto__" && Object.defineProperty(l, a, { enumerable: !0, configurable: !0, writable: !0 });
      }
      if (u)
        throw new B("trying to redefine an already defined value", {
          toml: e,
          ptr: t
        });
      let [d, h] = ar(e, g, "}", r - 1);
      i.add(d), l[a] = d, t = h, o = e[t - 1] === "," ? t - 1 : 0;
    }
  }
  if (o)
    throw new B("trailing commas are not allowed in inline tables", {
      toml: e,
      ptr: o
    });
  if (!s)
    throw new B("unfinished table encountered", {
      toml: e,
      ptr: t
    });
  return [n, t];
}
function Rc(e, t, r) {
  let n = [], i;
  for (t++; (i = e[t++]) !== "]" && i; ) {
    if (i === ",")
      throw new B("expected value, found comma", {
        toml: e,
        ptr: t - 1
      });
    if (i === "#")
      t = or(e, t);
    else if (i !== " " && i !== "	" && i !== `
` && i !== "\r") {
      let s = ar(e, t - 1, "]", r - 1);
      n.push(s[0]), t = s[1];
    }
  }
  if (!i)
    throw new B("unfinished array encountered", {
      toml: e,
      ptr: t
    });
  return [n, t];
}
function yn(e, t, r, n) {
  let i = t, s = r, o, a = !1, l;
  for (let u = 0; u < e.length; u++) {
    if (u) {
      if (i = a ? i[o] : i[o] = {}, s = (l = s[o]).c, n === 0 && (l.t === 1 || l.t === 2))
        return null;
      if (l.t === 2) {
        let c = i.length - 1;
        i = i[c], s = s[c].c;
      }
    }
    if (o = e[u], (a = Object.hasOwn(i, o)) && s[o]?.t === 0 && s[o]?.d)
      return null;
    a || (o === "__proto__" && (Object.defineProperty(i, o, { enumerable: !0, configurable: !0, writable: !0 }), Object.defineProperty(s, o, { enumerable: !0, configurable: !0, writable: !0 })), s[o] = {
      t: u < e.length - 1 && n === 2 ? 3 : n,
      d: !1,
      i: 0,
      c: {}
    });
  }
  if (l = s[o], l.t !== n && !(n === 1 && l.t === 3) || (n === 2 && (l.d || (l.d = !0, i[o] = []), i[o].push(i = {}), l.c[l.i++] = l = { t: 1, d: !1, i: 0, c: {} }), l.d))
    return null;
  if (l.d = !0, n === 1)
    i = a ? i[o] : i[o] = {};
  else if (n === 0 && a)
    return null;
  return [o, i, l.c];
}
function Ac(e, t) {
  let r = t?.maxDepth ?? 1e3, n = {}, i = {}, s = n, o = i;
  for (let a = ge(e, 0); a < e.length; ) {
    if (e[a] === "[") {
      let l = e[++a] === "[", u = Ut(e, a += +l, "]");
      if (l) {
        if (e[u[1] - 1] !== "]")
          throw new B("expected end of table declaration", {
            toml: e,
            ptr: u[1] - 1
          });
        u[1]++;
      }
      let c = yn(
        u[0],
        n,
        i,
        l ? 2 : 1
        /* Type.EXPLICIT */
      );
      if (!c)
        throw new B("trying to redefine an already defined table or value", {
          toml: e,
          ptr: a
        });
      o = c[2], s = c[1], a = u[1];
    } else {
      let l = Ut(e, a), u = yn(
        l[0],
        s,
        o,
        0
        /* Type.DOTTED */
      );
      if (!u)
        throw new B("trying to redefine an already defined table or value", {
          toml: e,
          ptr: a
        });
      let c = ar(e, l[1], void 0, r);
      u[1][u[0]] = c[0], a = c[1];
    }
    if (a = ge(e, a, !0), e[a] && e[a] !== `
` && e[a] !== "\r")
      throw new B("each key-value declaration must be followed by an end-of-line", {
        toml: e,
        ptr: a
      });
    a = ge(e, a);
  }
  return n;
}
const wc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TomlDate: we,
  TomlError: B,
  parse: Ac
}, Symbol.toStringTag, { value: "Module" }));
